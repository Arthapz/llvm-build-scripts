diff --git a/libcxx/docs/FeatureTestMacroTable.rst b/libcxx/docs/FeatureTestMacroTable.rst
index 17d2da907692e..21bd21ff2e70c 100644
--- a/libcxx/docs/FeatureTestMacroTable.rst
+++ b/libcxx/docs/FeatureTestMacroTable.rst
@@ -370,6 +370,8 @@ Status
     ---------------------------------------------------------- -----------------
     ``__cpp_lib_ranges_starts_ends_with``                      ``202106L``
     ---------------------------------------------------------- -----------------
+    ``__cpp_lib_ranges_stride``                                ``202207L``
+    ---------------------------------------------------------- -----------------
     ``__cpp_lib_ranges_to_container``                          ``202202L``
     ---------------------------------------------------------- -----------------
     ``__cpp_lib_ranges_zip``                                   *unimplemented*
diff --git a/libcxx/include/CMakeLists.txt b/libcxx/include/CMakeLists.txt
index 01e9c247560ca..3a2f7a2ad34e2 100644
--- a/libcxx/include/CMakeLists.txt
+++ b/libcxx/include/CMakeLists.txt
@@ -670,6 +670,7 @@ set(files
   __ranges/single_view.h
   __ranges/size.h
   __ranges/split_view.h
+  __ranges/stride_view.h
   __ranges/subrange.h
   __ranges/take_view.h
   __ranges/take_while_view.h
diff --git a/libcxx/include/__ranges/stride_view.h b/libcxx/include/__ranges/stride_view.h
new file mode 100644
index 0000000000000..25db3b2b03fcf
--- /dev/null
+++ b/libcxx/include/__ranges/stride_view.h
@@ -0,0 +1,418 @@
+// -*- C++ -*-
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef _LIBCPP___RANGES_STRIDE_VIEW_H
+#define _LIBCPP___RANGES_STRIDE_VIEW_H
+
+#include <__assert>
+#include <__compare/three_way_comparable.h>
+#include <__concepts/convertible_to.h>
+#include <__concepts/derived_from.h>
+#include <__concepts/equality_comparable.h>
+#include <__concepts/relation.h>
+#include <__config>
+#include <__functional/bind_back.h>
+#include <__functional/operations.h>
+#include <__functional/ranges_operations.h>
+#include <__iterator/advance.h>
+#include <__iterator/concepts.h>
+#include <__iterator/default_sentinel.h>
+#include <__iterator/distance.h>
+#include <__iterator/indirectly_comparable.h>
+#include <__iterator/iter_move.h>
+#include <__iterator/iter_swap.h>
+#include <__iterator/iterator_traits.h>
+#include <__ranges/access.h>
+#include <__ranges/all.h>
+#include <__ranges/concepts.h>
+#include <__ranges/enable_borrowed_range.h>
+#include <__ranges/range_adaptor.h>
+#include <__ranges/view_interface.h>
+
+#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
+#  pragma GCC system_header
+#endif
+
+_LIBCPP_PUSH_MACROS
+#include <__undef_macros>
+
+_LIBCPP_BEGIN_NAMESPACE_STD
+
+#if _LIBCPP_STD_VER >= 23
+
+namespace ranges {
+
+template <class _Value>
+_LIBCPP_HIDE_FROM_ABI constexpr _Value __div_ceil(_Value __left, _Value __right) {
+  _Value __r = __left / __right;
+  if (__left % __right) {
+    ++__r;
+  }
+  return __r;
+}
+
+template <input_range _View>
+  requires view<_View>
+class stride_view : public view_interface<stride_view<_View>> {
+  _LIBCPP_NO_UNIQUE_ADDRESS _View __base_ = _View();
+  range_difference_t<_View> __stride_     = 0;
+
+  template <bool _Const>
+  class __iterator;
+
+public:
+  _LIBCPP_HIDE_FROM_ABI constexpr explicit stride_view(_View __base, range_difference_t<_View> __stride)
+      : __base_(std::move(__base)), __stride_(__stride) {
+    _LIBCPP_ASSERT_UNCATEGORIZED(__stride > 0, "The value of stride must be greater than 0");
+  }
+
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI constexpr _View base() const&
+    requires copy_constructible<_View>
+  {
+    return __base_;
+  }
+
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI constexpr _View base() && { return std::move(__base_); }
+
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI constexpr range_difference_t<_View> stride() const noexcept {
+    return __stride_;
+  }
+
+  _LIBCPP_NODISCARD _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI constexpr auto begin()
+    requires(!__simple_view<_View>)
+  {
+    return __iterator<false>(this, ranges::begin(__base_), 0);
+  }
+
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI constexpr auto begin() const
+    requires range<const _View>
+  {
+    return __iterator<true>(this, ranges::begin(__base_), 0);
+  }
+
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI constexpr auto end()
+    requires(!__simple_view<_View>)
+  {
+    if constexpr (common_range<_View> && sized_range<_View> && forward_range<_View>) {
+      auto __missing = (__stride_ - ranges::distance(__base_) % __stride_) % __stride_;
+      return __iterator<false>(this, ranges::end(__base_), __missing);
+    } else if constexpr (common_range<_View> && !bidirectional_range<_View>) {
+      return __iterator<false>(this, ranges::end(__base_), 0);
+    } else {
+      return default_sentinel;
+    }
+  }
+
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI constexpr auto end() const
+    requires(range<const _View>)
+  {
+    if constexpr (common_range<const _View> && sized_range<const _View> && forward_range<const _View>) {
+      auto __missing = (__stride_ - ranges::distance(__base_) % __stride_) % __stride_;
+      return __iterator<true>(this, ranges::end(__base_), __missing);
+    } else if constexpr (common_range<_View> && !bidirectional_range<_View>) {
+      return __iterator<true>(this, ranges::end(__base_), 0);
+    } else {
+      return default_sentinel;
+    }
+  }
+
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI constexpr auto size()
+    requires sized_range<_View>
+  {
+    return std::__to_unsigned_like(ranges::__div_ceil(ranges::distance(__base_), __stride_));
+  }
+
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI constexpr auto size() const
+    requires sized_range<const _View>
+  {
+    return std::__to_unsigned_like(ranges::__div_ceil(ranges::distance(__base_), __stride_));
+  }
+}; // class stride_view
+
+template <class _Range>
+stride_view(_Range&&, range_difference_t<_Range>) -> stride_view<views::all_t<_Range>>;
+
+template <class _View>
+struct __stride_iterator_category {};
+
+template <forward_range _View>
+struct __stride_iterator_category<_View> {
+  using _Cat = typename iterator_traits<iterator_t<_View>>::iterator_category;
+  using iterator_category =
+      _If<derived_from<_Cat, random_access_iterator_tag>,
+          /* then */ random_access_iterator_tag,
+          /* else */ _Cat >;
+};
+
+template <input_range _View>
+  requires view<_View>
+template <bool _Const>
+class stride_view<_View>::__iterator : public __stride_iterator_category<_View> {
+  using _Parent = __maybe_const<_Const, stride_view<_View>>;
+  using _Base   = __maybe_const<_Const, _View>;
+
+  _LIBCPP_NO_UNIQUE_ADDRESS iterator_t<_Base> __current_     = iterator_t<_Base>();
+  _LIBCPP_NO_UNIQUE_ADDRESS ranges::sentinel_t<_Base> __end_ = ranges::sentinel_t<_Base>();
+  range_difference_t<_Base> __stride_                        = 0;
+  range_difference_t<_Base> __missing_                       = 0;
+
+  friend stride_view;
+
+  _LIBCPP_HIDE_FROM_ABI constexpr __iterator(
+      _Parent* __parent, ranges::iterator_t<_Base> __current, range_difference_t<_Base> __missing)
+      : __current_(std::move(__current)),
+        __end_(ranges::end(__parent->__base_)),
+        __stride_(__parent->__stride_),
+        __missing_(__missing) {}
+
+  static consteval auto __get_stride_view_iterator_concept() {
+    if constexpr (random_access_range<_Base>) {
+      return random_access_iterator_tag{};
+    } else if constexpr (bidirectional_range<_Base>) {
+      return bidirectional_iterator_tag{};
+    } else if constexpr (forward_range<_Base>) {
+      return forward_iterator_tag{};
+    } else {
+      return input_iterator_tag{};
+    }
+  }
+
+public:
+  using difference_type  = range_difference_t<_Base>;
+  using value_type       = range_value_t<_Base>;
+  using iterator_concept = decltype(__get_stride_view_iterator_concept());
+  // using iterator_category = inherited;
+
+  _LIBCPP_HIDE_FROM_ABI __iterator()
+    requires default_initializable<iterator_t<_Base>>
+  = default;
+
+  _LIBCPP_HIDE_FROM_ABI constexpr __iterator(__iterator<!_Const> __i)
+    requires _Const && convertible_to<ranges::iterator_t<_View>, iterator_t<_Base>> &&
+                 convertible_to<sentinel_t<_View>, sentinel_t<_Base>>
+      : __current_(std::move(__i.__current_)),
+        __end_(std::move(__i.__end_)),
+        __stride_(__i.__stride_),
+        __missing_(__i.__missing_) {}
+
+  _LIBCPP_HIDE_FROM_ABI constexpr iterator_t<_Base> const& base() const& noexcept { return __current_; }
+  _LIBCPP_HIDE_FROM_ABI constexpr iterator_t<_Base> base() && { return std::move(__current_); }
+
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI constexpr decltype(auto) operator*() const {
+    _LIBCPP_ASSERT_VALID_ELEMENT_ACCESS(__current_ != __end_, "Cannot dereference an iterator at the end.");
+    return *__current_;
+  }
+
+  _LIBCPP_HIDE_FROM_ABI constexpr __iterator& operator++() {
+    _LIBCPP_ASSERT_UNCATEGORIZED(__current_ != __end_, "Cannot increment an iterator already at the end.");
+    __missing_ = ranges::advance(__current_, __stride_, __end_);
+    return *this;
+  }
+
+  _LIBCPP_HIDE_FROM_ABI constexpr void operator++(int) {
+    _LIBCPP_ASSERT_UNCATEGORIZED(__current_ != __end_, "Cannot increment an iterator already at the end.");
+    ++*this;
+  }
+  _LIBCPP_HIDE_FROM_ABI constexpr __iterator operator++(int)
+    requires forward_range<_Base>
+  {
+    _LIBCPP_ASSERT_UNCATEGORIZED(__current_ != __end_, "Cannot increment an iterator already at the end.");
+    auto __tmp = *this;
+    ++*this;
+    return __tmp;
+  }
+
+  _LIBCPP_HIDE_FROM_ABI constexpr __iterator& operator--()
+    requires bidirectional_range<_Base>
+  {
+    ranges::advance(__current_, __missing_ - __stride_);
+    __missing_ = 0;
+    return *this;
+  }
+  _LIBCPP_HIDE_FROM_ABI constexpr __iterator operator--(int)
+    requires bidirectional_range<_Base>
+  {
+    auto __tmp = *this;
+    --*this;
+    return __tmp;
+  }
+
+  _LIBCPP_HIDE_FROM_ABI constexpr __iterator& operator+=(difference_type __n)
+    requires random_access_range<_Base>
+  {
+    if (__n > 0) {
+      _LIBCPP_ASSERT_UNCATEGORIZED(ranges::distance(__current_, __end_) > __stride_ * (__n - 1),
+                                   "Advancing the iterator beyond the end is not allowed.");
+      ranges::advance(__current_, __stride_ * (__n - 1));
+      __missing_ = ranges::advance(__current_, __stride_, __end_);
+
+    } else if (__n < 0) {
+      ranges::advance(__current_, __stride_ * __n + __missing_);
+      __missing_ = 0;
+    }
+    return *this;
+  }
+
+  _LIBCPP_HIDE_FROM_ABI constexpr __iterator& operator-=(difference_type __n)
+    requires random_access_range<_Base>
+  {
+    return *this += -__n;
+  }
+
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI constexpr decltype(auto) operator[](difference_type __n) const
+    requires random_access_range<_Base>
+  {
+    return *(*this + __n);
+  }
+
+  _LIBCPP_HIDE_FROM_ABI friend constexpr bool operator==(__iterator const& __x, default_sentinel_t) {
+    return __x.__current_ == __x.__end_;
+  }
+
+  _LIBCPP_HIDE_FROM_ABI friend constexpr bool operator==(__iterator const& __x, __iterator const& __y)
+    requires equality_comparable<iterator_t<_Base>>
+  {
+    return __x.__current_ == __y.__current_;
+  }
+
+  _LIBCPP_HIDE_FROM_ABI friend constexpr bool operator<(__iterator const& __x, __iterator const& __y)
+    requires random_access_range<_Base>
+  {
+    return __x.__current_ < __y.__current_;
+  }
+
+  _LIBCPP_HIDE_FROM_ABI friend constexpr bool operator>(__iterator const& __x, __iterator const& __y)
+    requires random_access_range<_Base>
+  {
+    return __y < __x;
+  }
+
+  _LIBCPP_HIDE_FROM_ABI friend constexpr bool operator<=(__iterator const& __x, __iterator const& __y)
+    requires random_access_range<_Base>
+  {
+    return !(__y < __x);
+  }
+
+  _LIBCPP_HIDE_FROM_ABI friend constexpr bool operator>=(__iterator const& __x, __iterator const& __y)
+    requires random_access_range<_Base>
+  {
+    return !(__x < __y);
+  }
+
+  _LIBCPP_HIDE_FROM_ABI friend constexpr auto operator<=>(__iterator const& __x, __iterator const& __y)
+    requires random_access_range<_Base> && three_way_comparable<iterator_t<_Base>>
+  {
+    return __x.__current_ <=> __y.__current_;
+  }
+
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI friend constexpr __iterator
+  operator+(__iterator const& __i, difference_type __s)
+    requires random_access_range<_Base>
+  {
+    auto __r = __i;
+    __r += __s;
+    return __r;
+  }
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI friend constexpr __iterator
+  operator+(difference_type __s, __iterator const& __i)
+    requires random_access_range<_Base>
+  {
+    auto __r = __i;
+    __r += __s;
+    return __r;
+  }
+
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI friend constexpr __iterator
+  operator-(__iterator const& __i, difference_type __s)
+    requires random_access_range<_Base>
+  {
+    auto __r = __i;
+    __r -= __s;
+    return __r;
+  }
+
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI friend constexpr difference_type
+  operator-(__iterator const& __x, __iterator const& __y)
+    requires sized_sentinel_for<iterator_t<_Base>, iterator_t<_Base>> && forward_range<_Base>
+  {
+    auto __n = __x.__current_ - __y.__current_;
+    return (__n + __x.__missing_ - __y.__missing_) / __x.__stride_;
+  }
+
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI friend constexpr difference_type
+  operator-(__iterator const& __x, __iterator const& __y)
+    requires sized_sentinel_for<iterator_t<_Base>, iterator_t<_Base>>
+  {
+    auto __n = __x.__current_ - __y.__current_;
+    if (__n < 0) {
+      return -ranges::__div_ceil(-__n, __x.__stride_);
+    }
+    return ranges::__div_ceil(__n, __x.__stride_);
+  }
+
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI friend constexpr difference_type
+  operator-(default_sentinel_t, __iterator const& __x)
+    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>
+  {
+    return ranges::__div_ceil(__x.__end_ - __x.__current_, __x.__stride_);
+  }
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI friend constexpr difference_type
+  operator-(__iterator const& __x, default_sentinel_t __y)
+    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>
+  {
+    return -(__y - __x);
+  }
+
+  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI friend constexpr range_rvalue_reference_t<_Base>
+  iter_move(__iterator const& __it) noexcept(noexcept(ranges::iter_move(__it.__current_))) {
+    return ranges::iter_move(__it.__current_);
+  }
+
+  _LIBCPP_HIDE_FROM_ABI friend constexpr void
+  iter_swap(__iterator const& __x,
+            __iterator const& __y) noexcept(noexcept(ranges::iter_swap(__x.__current_, __y.__current_)))
+    requires indirectly_swappable<iterator_t<_Base>>
+  {
+    return ranges::iter_swap(__x.__current_, __y.__current_);
+  }
+}; // class stride_view::__iterator
+
+template <class _Tp>
+inline constexpr bool enable_borrowed_range<stride_view<_Tp>> = enable_borrowed_range<_Tp>;
+
+namespace views {
+namespace __stride {
+struct __fn {
+  template <viewable_range _Range>
+  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI constexpr auto operator()(_Range&& __range, range_difference_t<_Range> __n) const
+      noexcept(noexcept(/**/ stride_view{
+          std::forward<_Range>(__range), __n})) -> decltype(/*--*/ stride_view{std::forward<_Range>(__range), __n}) {
+    return /*-------------*/ stride_view(std::forward<_Range>(__range), __n);
+  }
+
+  template <class _Np>
+  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI constexpr auto operator()(_Np&& __n) const {
+    return __range_adaptor_closure_t(std::__bind_back(*this, std::forward<_Np>(__n)));
+  }
+};
+} // namespace __stride
+
+inline namespace __cpo {
+inline constexpr auto stride = __stride::__fn{};
+} // namespace __cpo
+} // namespace views
+} // namespace ranges
+
+#endif // _LIBCPP_STD_VER >= 23
+
+_LIBCPP_END_NAMESPACE_STD
+
+_LIBCPP_POP_MACROS
+
+#endif // _LIBCPP___RANGES_STRIDE_VIEW_H
diff --git a/libcxx/include/libcxx.imp b/libcxx/include/libcxx.imp
new file mode 100644
index 0000000000000..26397c1216a76
--- /dev/null
+++ b/libcxx/include/libcxx.imp
@@ -0,0 +1,869 @@
+[
+  { include: [ "<__algorithm/adjacent_find.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/all_of.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/any_of.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/binary_search.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/clamp.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/comp.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/comp_ref_type.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/copy_backward.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/copy_if.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/copy_move_common.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/copy_n.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/count.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/count_if.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/equal.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/equal_range.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/fill.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/fill_n.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/find.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/find_end.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/find_first_of.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/find_if.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/find_if_not.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/find_segment_if.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/fold.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/for_each.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/for_each_n.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/for_each_segment.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/generate.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/generate_n.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/half_positive.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/in_found_result.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/in_fun_result.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/in_in_out_result.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/in_in_result.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/in_out_out_result.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/in_out_result.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/includes.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/inplace_merge.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/is_heap.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/is_heap_until.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/is_partitioned.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/is_permutation.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/is_sorted.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/is_sorted_until.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/iter_swap.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/iterator_operations.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/lexicographical_compare.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/lexicographical_compare_three_way.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/lower_bound.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/make_heap.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/make_projected.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/max.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/max_element.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/merge.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/min.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/min_element.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/min_max_result.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/minmax.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/minmax_element.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/mismatch.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/move.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/move_backward.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/next_permutation.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/none_of.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/nth_element.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/partial_sort.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/partial_sort_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/partition.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/partition_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/partition_point.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pop_heap.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/prev_permutation.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_any_all_none_of.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_backend.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_backends/cpu_backend.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_backends/cpu_backends/any_of.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_backends/cpu_backends/backend.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_backends/cpu_backends/fill.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_backends/cpu_backends/find_if.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_backends/cpu_backends/for_each.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_backends/cpu_backends/libdispatch.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_backends/cpu_backends/merge.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_backends/cpu_backends/serial.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_backends/cpu_backends/stable_sort.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_backends/cpu_backends/thread.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_backends/cpu_backends/transform.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_backends/cpu_backends/transform_reduce.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_count.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_equal.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_fill.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_find.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_for_each.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_frontend_dispatch.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_generate.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_is_partitioned.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_merge.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_move.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_replace.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_rotate_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_sort.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_stable_sort.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/pstl_transform.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/push_heap.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_adjacent_find.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_all_of.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_any_of.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_binary_search.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_clamp.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_contains.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_copy_backward.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_copy_if.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_copy_n.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_count.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_count_if.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_ends_with.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_equal.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_equal_range.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_fill.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_fill_n.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_find.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_find_end.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_find_first_of.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_find_if.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_find_if_not.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_for_each.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_for_each_n.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_generate.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_generate_n.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_includes.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_inplace_merge.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_is_heap.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_is_heap_until.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_is_partitioned.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_is_permutation.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_is_sorted.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_is_sorted_until.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_iterator_concept.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_lexicographical_compare.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_lower_bound.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_make_heap.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_max.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_max_element.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_merge.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_min.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_min_element.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_minmax.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_minmax_element.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_mismatch.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_move.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_move_backward.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_next_permutation.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_none_of.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_nth_element.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_partial_sort.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_partial_sort_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_partition.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_partition_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_partition_point.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_pop_heap.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_prev_permutation.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_push_heap.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_remove.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_remove_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_remove_copy_if.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_remove_if.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_replace.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_replace_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_replace_copy_if.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_replace_if.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_reverse.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_reverse_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_rotate.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_rotate_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_sample.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_search.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_search_n.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_set_difference.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_set_intersection.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_set_symmetric_difference.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_set_union.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_shuffle.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_sort.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_sort_heap.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_stable_partition.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_stable_sort.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_starts_with.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_swap_ranges.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_transform.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_unique.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_unique_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/ranges_upper_bound.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/remove.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/remove_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/remove_copy_if.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/remove_if.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/replace.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/replace_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/replace_copy_if.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/replace_if.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/reverse.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/reverse_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/rotate.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/rotate_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/sample.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/search.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/search_n.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/set_difference.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/set_intersection.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/set_symmetric_difference.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/set_union.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/shift_left.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/shift_right.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/shuffle.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/sift_down.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/sort.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/sort_heap.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/stable_partition.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/stable_sort.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/swap_ranges.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/three_way_comp_ref_type.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/transform.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/uniform_random_bit_generator_adaptor.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/unique.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/unique_copy.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/unwrap_iter.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/unwrap_range.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__algorithm/upper_bound.h>", "private", "<algorithm>", "public" ] },
+  { include: [ "<__atomic/aliases.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__atomic/atomic.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__atomic/atomic_base.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__atomic/atomic_flag.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__atomic/atomic_init.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__atomic/atomic_lock_free.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__atomic/atomic_sync.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__atomic/check_memory_order.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__atomic/contention_t.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__atomic/cxx_atomic_impl.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__atomic/fence.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__atomic/is_always_lock_free.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__atomic/kill_dependency.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__atomic/memory_order.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__bit/bit_cast.h>", "private", "<bit>", "public" ] },
+  { include: [ "<__bit/bit_ceil.h>", "private", "<bit>", "public" ] },
+  { include: [ "<__bit/bit_floor.h>", "private", "<bit>", "public" ] },
+  { include: [ "<__bit/bit_log2.h>", "private", "<bit>", "public" ] },
+  { include: [ "<__bit/bit_width.h>", "private", "<bit>", "public" ] },
+  { include: [ "<__bit/blsr.h>", "private", "<bit>", "public" ] },
+  { include: [ "<__bit/byteswap.h>", "private", "<bit>", "public" ] },
+  { include: [ "<__bit/countl.h>", "private", "<bit>", "public" ] },
+  { include: [ "<__bit/countr.h>", "private", "<bit>", "public" ] },
+  { include: [ "<__bit/endian.h>", "private", "<bit>", "public" ] },
+  { include: [ "<__bit/has_single_bit.h>", "private", "<bit>", "public" ] },
+  { include: [ "<__bit/invert_if.h>", "private", "<bit>", "public" ] },
+  { include: [ "<__bit/popcount.h>", "private", "<bit>", "public" ] },
+  { include: [ "<__bit/rotate.h>", "private", "<bit>", "public" ] },
+  { include: [ "<__charconv/chars_format.h>", "private", "<charconv>", "public" ] },
+  { include: [ "<__charconv/from_chars_integral.h>", "private", "<charconv>", "public" ] },
+  { include: [ "<__charconv/from_chars_result.h>", "private", "<charconv>", "public" ] },
+  { include: [ "<__charconv/tables.h>", "private", "<charconv>", "public" ] },
+  { include: [ "<__charconv/to_chars.h>", "private", "<charconv>", "public" ] },
+  { include: [ "<__charconv/to_chars_base_10.h>", "private", "<charconv>", "public" ] },
+  { include: [ "<__charconv/to_chars_floating_point.h>", "private", "<charconv>", "public" ] },
+  { include: [ "<__charconv/to_chars_integral.h>", "private", "<charconv>", "public" ] },
+  { include: [ "<__charconv/to_chars_result.h>", "private", "<charconv>", "public" ] },
+  { include: [ "<__charconv/traits.h>", "private", "<charconv>", "public" ] },
+  { include: [ "<__chrono/calendar.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/concepts.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/convert_to_timespec.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/convert_to_tm.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/day.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/duration.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/file_clock.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/formatter.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/hh_mm_ss.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/high_resolution_clock.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/literals.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/month.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/month_weekday.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/monthday.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/ostream.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/parser_std_format_spec.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/statically_widen.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/steady_clock.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/system_clock.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/time_point.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/tzdb.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/tzdb_list.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/weekday.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/year.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/year_month.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/year_month_day.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__chrono/year_month_weekday.h>", "private", "<chrono>", "public" ] },
+  { include: [ "<__compare/common_comparison_category.h>", "private", "<compare>", "public" ] },
+  { include: [ "<__compare/compare_partial_order_fallback.h>", "private", "<compare>", "public" ] },
+  { include: [ "<__compare/compare_strong_order_fallback.h>", "private", "<compare>", "public" ] },
+  { include: [ "<__compare/compare_three_way.h>", "private", "<compare>", "public" ] },
+  { include: [ "<__compare/compare_three_way_result.h>", "private", "<compare>", "public" ] },
+  { include: [ "<__compare/compare_weak_order_fallback.h>", "private", "<compare>", "public" ] },
+  { include: [ "<__compare/is_eq.h>", "private", "<compare>", "public" ] },
+  { include: [ "<__compare/ordering.h>", "private", "<compare>", "public" ] },
+  { include: [ "<__compare/partial_order.h>", "private", "<compare>", "public" ] },
+  { include: [ "<__compare/strong_order.h>", "private", "<compare>", "public" ] },
+  { include: [ "<__compare/synth_three_way.h>", "private", "<compare>", "public" ] },
+  { include: [ "<__compare/three_way_comparable.h>", "private", "<compare>", "public" ] },
+  { include: [ "<__compare/weak_order.h>", "private", "<compare>", "public" ] },
+  { include: [ "<__concepts/arithmetic.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/assignable.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/boolean_testable.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/class_or_enum.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/common_reference_with.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/common_with.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/constructible.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/convertible_to.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/copyable.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/derived_from.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/destructible.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/different_from.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/equality_comparable.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/invocable.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/movable.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/predicate.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/regular.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/relation.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/same_as.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/semiregular.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/swappable.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__concepts/totally_ordered.h>", "private", "<concepts>", "public" ] },
+  { include: [ "<__condition_variable/condition_variable.h>", "private", "<condition_variable>", "public" ] },
+  { include: [ "<__coroutine/coroutine_handle.h>", "private", "<coroutine>", "public" ] },
+  { include: [ "<__coroutine/coroutine_traits.h>", "private", "<coroutine>", "public" ] },
+  { include: [ "<__coroutine/noop_coroutine_handle.h>", "private", "<coroutine>", "public" ] },
+  { include: [ "<__coroutine/trivial_awaitables.h>", "private", "<coroutine>", "public" ] },
+  { include: [ "<__exception/exception.h>", "private", "<exception>", "public" ] },
+  { include: [ "<__exception/exception_ptr.h>", "private", "<exception>", "public" ] },
+  { include: [ "<__exception/nested_exception.h>", "private", "<exception>", "public" ] },
+  { include: [ "<__exception/operations.h>", "private", "<exception>", "public" ] },
+  { include: [ "<__exception/terminate.h>", "private", "<exception>", "public" ] },
+  { include: [ "<__expected/bad_expected_access.h>", "private", "<expected>", "public" ] },
+  { include: [ "<__expected/expected.h>", "private", "<expected>", "public" ] },
+  { include: [ "<__expected/unexpect.h>", "private", "<expected>", "public" ] },
+  { include: [ "<__expected/unexpected.h>", "private", "<expected>", "public" ] },
+  { include: [ "<__filesystem/copy_options.h>", "private", "<filesystem>", "public" ] },
+  { include: [ "<__filesystem/directory_entry.h>", "private", "<filesystem>", "public" ] },
+  { include: [ "<__filesystem/directory_iterator.h>", "private", "<filesystem>", "public" ] },
+  { include: [ "<__filesystem/directory_options.h>", "private", "<filesystem>", "public" ] },
+  { include: [ "<__filesystem/file_status.h>", "private", "<filesystem>", "public" ] },
+  { include: [ "<__filesystem/file_time_type.h>", "private", "<filesystem>", "public" ] },
+  { include: [ "<__filesystem/file_type.h>", "private", "<filesystem>", "public" ] },
+  { include: [ "<__filesystem/filesystem_error.h>", "private", "<filesystem>", "public" ] },
+  { include: [ "<__filesystem/operations.h>", "private", "<filesystem>", "public" ] },
+  { include: [ "<__filesystem/path.h>", "private", "<filesystem>", "public" ] },
+  { include: [ "<__filesystem/path_iterator.h>", "private", "<filesystem>", "public" ] },
+  { include: [ "<__filesystem/perm_options.h>", "private", "<filesystem>", "public" ] },
+  { include: [ "<__filesystem/perms.h>", "private", "<filesystem>", "public" ] },
+  { include: [ "<__filesystem/recursive_directory_iterator.h>", "private", "<filesystem>", "public" ] },
+  { include: [ "<__filesystem/space_info.h>", "private", "<filesystem>", "public" ] },
+  { include: [ "<__filesystem/u8path.h>", "private", "<filesystem>", "public" ] },
+  { include: [ "<__format/buffer.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/concepts.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/container_adaptor.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/enable_insertable.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/escaped_output_table.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/extended_grapheme_cluster_table.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/format_arg.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/format_arg_store.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/format_args.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/format_context.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/format_error.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/format_functions.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/format_fwd.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/format_parse_context.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/format_string.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/format_to_n_result.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/formatter.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/formatter_bool.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/formatter_char.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/formatter_floating_point.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/formatter_integer.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/formatter_integral.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/formatter_output.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/formatter_pointer.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/formatter_string.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/formatter_tuple.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/parser_std_format_spec.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/range_default_formatter.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/range_formatter.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/unicode.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/width_estimation_table.h>", "private", "<format>", "public" ] },
+  { include: [ "<__format/write_escaped.h>", "private", "<format>", "public" ] },
+  { include: [ "<__functional/binary_function.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/binary_negate.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/bind.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/bind_back.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/bind_front.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/binder1st.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/binder2nd.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/boyer_moore_searcher.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/compose.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/default_searcher.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/function.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/hash.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/identity.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/invoke.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/is_transparent.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/mem_fn.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/mem_fun_ref.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/not_fn.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/operations.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/perfect_forward.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/pointer_to_binary_function.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/pointer_to_unary_function.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/ranges_operations.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/reference_wrapper.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/unary_function.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/unary_negate.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__functional/weak_result_type.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__fwd/array.h>", "private", "<array>", "public" ] },
+  { include: [ "<__fwd/bit_reference.h>", "private", "<bitset>", "public" ] },
+  { include: [ "<__fwd/bit_reference.h>", "private", "<vector>", "public" ] },
+  { include: [ "<__fwd/fstream.h>", "private", "<fstream>", "public" ] },
+  { include: [ "<__fwd/hash.h>", "private", "<functional>", "public" ] },
+  { include: [ "<__fwd/ios.h>", "private", "<ios>", "public" ] },
+  { include: [ "<__fwd/istream.h>", "private", "<istream>", "public" ] },
+  { include: [ "<__fwd/mdspan.h>", "private", "<mdspan>", "public" ] },
+  { include: [ "<__fwd/memory_resource.h>", "private", "<memory_resource>", "public" ] },
+  { include: [ "<__fwd/ostream.h>", "private", "<ostream>", "public" ] },
+  { include: [ "<__fwd/pair.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__fwd/span.h>", "private", "<span>", "public" ] },
+  { include: [ "<__fwd/sstream.h>", "private", "<sstream>", "public" ] },
+  { include: [ "<__fwd/streambuf.h>", "private", "<streambuf>", "public" ] },
+  { include: [ "<__fwd/string.h>", "private", "<string>", "public" ] },
+  { include: [ "<__fwd/string_view.h>", "private", "<string_view>", "public" ] },
+  { include: [ "<__fwd/subrange.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__fwd/tuple.h>", "private", "<tuple>", "public" ] },
+  { include: [ "<__ios/fpos.h>", "private", "<ios>", "public" ] },
+  { include: [ "<__iterator/access.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/advance.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/back_insert_iterator.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/bounded_iter.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/common_iterator.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/concepts.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/counted_iterator.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/cpp17_iterator_concepts.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/data.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/default_sentinel.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/distance.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/empty.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/erase_if_container.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/front_insert_iterator.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/incrementable_traits.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/indirectly_comparable.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/insert_iterator.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/istream_iterator.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/istreambuf_iterator.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/iter_move.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/iter_swap.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/iterator.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/iterator_traits.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/iterator_with_data.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/mergeable.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/move_iterator.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/move_sentinel.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/next.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/ostream_iterator.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/ostreambuf_iterator.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/permutable.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/prev.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/projected.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/ranges_iterator_traits.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/readable_traits.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/reverse_access.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/reverse_iterator.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/segmented_iterator.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/size.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/sortable.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/unreachable_sentinel.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__iterator/wrap_iter.h>", "private", "<iterator>", "public" ] },
+  { include: [ "<__locale_dir/locale_base_api.h>", "private", "<locale>", "public" ] },
+  { include: [ "<__locale_dir/locale_base_api/android.h>", "private", "<locale>", "public" ] },
+  { include: [ "<__locale_dir/locale_base_api/bsd_locale_defaults.h>", "private", "<locale>", "public" ] },
+  { include: [ "<__locale_dir/locale_base_api/bsd_locale_fallbacks.h>", "private", "<locale>", "public" ] },
+  { include: [ "<__locale_dir/locale_base_api/fuchsia.h>", "private", "<locale>", "public" ] },
+  { include: [ "<__locale_dir/locale_base_api/ibm.h>", "private", "<locale>", "public" ] },
+  { include: [ "<__locale_dir/locale_base_api/locale_guard.h>", "private", "<locale>", "public" ] },
+  { include: [ "<__locale_dir/locale_base_api/musl.h>", "private", "<locale>", "public" ] },
+  { include: [ "<__locale_dir/locale_base_api/newlib.h>", "private", "<locale>", "public" ] },
+  { include: [ "<__locale_dir/locale_base_api/openbsd.h>", "private", "<locale>", "public" ] },
+  { include: [ "<__locale_dir/locale_base_api/win32.h>", "private", "<locale>", "public" ] },
+  { include: [ "<__math/abs.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/copysign.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/error_functions.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/exponential_functions.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/fdim.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/fma.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/gamma.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/hyperbolic_functions.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/hypot.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/inverse_hyperbolic_functions.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/inverse_trigonometric_functions.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/logarithms.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/min_max.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/modulo.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/remainder.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/roots.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/rounding_functions.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/traits.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__math/trigonometric_functions.h>", "private", "<cmath>", "public" ] },
+  { include: [ "<__mdspan/default_accessor.h>", "private", "<mdspan>", "public" ] },
+  { include: [ "<__mdspan/extents.h>", "private", "<mdspan>", "public" ] },
+  { include: [ "<__mdspan/layout_left.h>", "private", "<mdspan>", "public" ] },
+  { include: [ "<__mdspan/layout_right.h>", "private", "<mdspan>", "public" ] },
+  { include: [ "<__mdspan/layout_stride.h>", "private", "<mdspan>", "public" ] },
+  { include: [ "<__mdspan/mdspan.h>", "private", "<mdspan>", "public" ] },
+  { include: [ "<__memory/addressof.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/align.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/aligned_alloc.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/allocate_at_least.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/allocation_guard.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/allocator.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/allocator_arg_t.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/allocator_destructor.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/allocator_traits.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/assume_aligned.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/auto_ptr.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/builtin_new_allocator.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/compressed_pair.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/concepts.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/construct_at.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/destruct_n.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/pointer_traits.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/ranges_construct_at.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/ranges_uninitialized_algorithms.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/raw_storage_iterator.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/shared_ptr.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/swap_allocator.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/temp_value.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/temporary_buffer.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/uninitialized_algorithms.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/unique_ptr.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/uses_allocator.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/uses_allocator_construction.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory/voidify.h>", "private", "<memory>", "public" ] },
+  { include: [ "<__memory_resource/memory_resource.h>", "private", "<memory_resource>", "public" ] },
+  { include: [ "<__memory_resource/monotonic_buffer_resource.h>", "private", "<memory_resource>", "public" ] },
+  { include: [ "<__memory_resource/polymorphic_allocator.h>", "private", "<memory_resource>", "public" ] },
+  { include: [ "<__memory_resource/pool_options.h>", "private", "<memory_resource>", "public" ] },
+  { include: [ "<__memory_resource/synchronized_pool_resource.h>", "private", "<memory_resource>", "public" ] },
+  { include: [ "<__memory_resource/unsynchronized_pool_resource.h>", "private", "<memory_resource>", "public" ] },
+  { include: [ "<__mutex/lock_guard.h>", "private", "<mutex>", "public" ] },
+  { include: [ "<__mutex/mutex.h>", "private", "<mutex>", "public" ] },
+  { include: [ "<__mutex/once_flag.h>", "private", "<mutex>", "public" ] },
+  { include: [ "<__mutex/tag_types.h>", "private", "<mutex>", "public" ] },
+  { include: [ "<__mutex/unique_lock.h>", "private", "<mutex>", "public" ] },
+  { include: [ "<__numeric/accumulate.h>", "private", "<numeric>", "public" ] },
+  { include: [ "<__numeric/adjacent_difference.h>", "private", "<numeric>", "public" ] },
+  { include: [ "<__numeric/exclusive_scan.h>", "private", "<numeric>", "public" ] },
+  { include: [ "<__numeric/gcd_lcm.h>", "private", "<numeric>", "public" ] },
+  { include: [ "<__numeric/inclusive_scan.h>", "private", "<numeric>", "public" ] },
+  { include: [ "<__numeric/inner_product.h>", "private", "<numeric>", "public" ] },
+  { include: [ "<__numeric/iota.h>", "private", "<numeric>", "public" ] },
+  { include: [ "<__numeric/midpoint.h>", "private", "<numeric>", "public" ] },
+  { include: [ "<__numeric/partial_sum.h>", "private", "<numeric>", "public" ] },
+  { include: [ "<__numeric/pstl_reduce.h>", "private", "<numeric>", "public" ] },
+  { include: [ "<__numeric/pstl_transform_reduce.h>", "private", "<numeric>", "public" ] },
+  { include: [ "<__numeric/reduce.h>", "private", "<numeric>", "public" ] },
+  { include: [ "<__numeric/saturation_arithmetic.h>", "private", "<numeric>", "public" ] },
+  { include: [ "<__numeric/transform_exclusive_scan.h>", "private", "<numeric>", "public" ] },
+  { include: [ "<__numeric/transform_inclusive_scan.h>", "private", "<numeric>", "public" ] },
+  { include: [ "<__numeric/transform_reduce.h>", "private", "<numeric>", "public" ] },
+  { include: [ "<__random/bernoulli_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/binomial_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/cauchy_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/chi_squared_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/clamp_to_integral.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/default_random_engine.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/discard_block_engine.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/discrete_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/exponential_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/extreme_value_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/fisher_f_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/gamma_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/generate_canonical.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/geometric_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/independent_bits_engine.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/is_seed_sequence.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/is_valid.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/knuth_b.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/linear_congruential_engine.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/log2.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/lognormal_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/mersenne_twister_engine.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/negative_binomial_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/normal_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/piecewise_constant_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/piecewise_linear_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/poisson_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/random_device.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/ranlux.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/seed_seq.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/shuffle_order_engine.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/student_t_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/subtract_with_carry_engine.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/uniform_int_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/uniform_random_bit_generator.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/uniform_real_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__random/weibull_distribution.h>", "private", "<random>", "public" ] },
+  { include: [ "<__ranges/access.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/all.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/as_rvalue_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/chunk_by_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/common_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/concepts.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/container_compatible_range.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/counted.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/dangling.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/data.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/drop_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/drop_while_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/elements_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/empty.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/empty_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/enable_borrowed_range.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/enable_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/filter_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/from_range.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/iota_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/istream_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/join_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/lazy_split_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/movable_box.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/non_propagating_cache.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/owning_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/range_adaptor.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/rbegin.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/ref_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/rend.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/repeat_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/reverse_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/single_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/size.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/split_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/stride_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/subrange.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/take_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/take_while_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/to.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/transform_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/view_interface.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/views.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__ranges/zip_view.h>", "private", "<ranges>", "public" ] },
+  { include: [ "<__stop_token/atomic_unique_lock.h>", "private", "<stop_token>", "public" ] },
+  { include: [ "<__stop_token/intrusive_list_view.h>", "private", "<stop_token>", "public" ] },
+  { include: [ "<__stop_token/intrusive_shared_ptr.h>", "private", "<stop_token>", "public" ] },
+  { include: [ "<__stop_token/stop_callback.h>", "private", "<stop_token>", "public" ] },
+  { include: [ "<__stop_token/stop_source.h>", "private", "<stop_token>", "public" ] },
+  { include: [ "<__stop_token/stop_state.h>", "private", "<stop_token>", "public" ] },
+  { include: [ "<__stop_token/stop_token.h>", "private", "<stop_token>", "public" ] },
+  { include: [ "<__string/char_traits.h>", "private", "<string>", "public" ] },
+  { include: [ "<__string/constexpr_c_functions.h>", "private", "<string>", "public" ] },
+  { include: [ "<__string/extern_template_lists.h>", "private", "<string>", "public" ] },
+  { include: [ "<__system_error/errc.h>", "private", "<system_error>", "public" ] },
+  { include: [ "<__system_error/error_category.h>", "private", "<system_error>", "public" ] },
+  { include: [ "<__system_error/error_code.h>", "private", "<system_error>", "public" ] },
+  { include: [ "<__system_error/error_condition.h>", "private", "<system_error>", "public" ] },
+  { include: [ "<__system_error/system_error.h>", "private", "<system_error>", "public" ] },
+  { include: [ "<__thread/formatter.h>", "private", "<thread>", "public" ] },
+  { include: [ "<__thread/id.h>", "private", "<thread>", "public" ] },
+  { include: [ "<__thread/jthread.h>", "private", "<thread>", "public" ] },
+  { include: [ "<__thread/poll_with_backoff.h>", "private", "<thread>", "public" ] },
+  { include: [ "<__thread/support.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__thread/support.h>", "private", "<mutex>", "public" ] },
+  { include: [ "<__thread/support.h>", "private", "<semaphore>", "public" ] },
+  { include: [ "<__thread/support.h>", "private", "<thread>", "public" ] },
+  { include: [ "<__thread/support/c11.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__thread/support/c11.h>", "private", "<mutex>", "public" ] },
+  { include: [ "<__thread/support/c11.h>", "private", "<semaphore>", "public" ] },
+  { include: [ "<__thread/support/c11.h>", "private", "<thread>", "public" ] },
+  { include: [ "<__thread/support/external.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__thread/support/external.h>", "private", "<mutex>", "public" ] },
+  { include: [ "<__thread/support/external.h>", "private", "<semaphore>", "public" ] },
+  { include: [ "<__thread/support/external.h>", "private", "<thread>", "public" ] },
+  { include: [ "<__thread/support/pthread.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__thread/support/pthread.h>", "private", "<mutex>", "public" ] },
+  { include: [ "<__thread/support/pthread.h>", "private", "<semaphore>", "public" ] },
+  { include: [ "<__thread/support/pthread.h>", "private", "<thread>", "public" ] },
+  { include: [ "<__thread/support/windows.h>", "private", "<atomic>", "public" ] },
+  { include: [ "<__thread/support/windows.h>", "private", "<mutex>", "public" ] },
+  { include: [ "<__thread/support/windows.h>", "private", "<semaphore>", "public" ] },
+  { include: [ "<__thread/support/windows.h>", "private", "<thread>", "public" ] },
+  { include: [ "<__thread/this_thread.h>", "private", "<thread>", "public" ] },
+  { include: [ "<__thread/thread.h>", "private", "<thread>", "public" ] },
+  { include: [ "<__thread/timed_backoff_policy.h>", "private", "<thread>", "public" ] },
+  { include: [ "<__tuple/make_tuple_types.h>", "private", "<tuple>", "public" ] },
+  { include: [ "<__tuple/pair_like.h>", "private", "<tuple>", "public" ] },
+  { include: [ "<__tuple/sfinae_helpers.h>", "private", "<tuple>", "public" ] },
+  { include: [ "<__tuple/tuple_element.h>", "private", "<tuple>", "public" ] },
+  { include: [ "<__tuple/tuple_indices.h>", "private", "<tuple>", "public" ] },
+  { include: [ "<__tuple/tuple_like.h>", "private", "<tuple>", "public" ] },
+  { include: [ "<__tuple/tuple_like_ext.h>", "private", "<tuple>", "public" ] },
+  { include: [ "<__tuple/tuple_size.h>", "private", "<tuple>", "public" ] },
+  { include: [ "<__tuple/tuple_types.h>", "private", "<tuple>", "public" ] },
+  { include: [ "<__type_traits/add_const.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/add_cv.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/add_lvalue_reference.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/add_pointer.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/add_rvalue_reference.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/add_volatile.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/aligned_storage.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/aligned_union.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/alignment_of.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/apply_cv.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/can_extract_key.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/common_reference.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/common_type.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/conditional.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/conjunction.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/copy_cv.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/copy_cvref.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/datasizeof.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/decay.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/dependent_type.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/disjunction.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/enable_if.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/extent.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/has_unique_object_representation.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/has_virtual_destructor.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/integral_constant.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/invoke.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_abstract.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_aggregate.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_allocator.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_always_bitcastable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_arithmetic.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_array.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_assignable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_base_of.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_bounded_array.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_callable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_char_like_type.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_class.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_compound.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_const.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_constant_evaluated.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_constructible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_convertible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_copy_assignable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_copy_constructible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_core_convertible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_default_constructible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_destructible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_empty.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_enum.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_equality_comparable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_execution_policy.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_final.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_floating_point.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_function.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_fundamental.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_implicitly_default_constructible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_integral.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_literal_type.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_member_function_pointer.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_member_object_pointer.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_member_pointer.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_move_assignable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_move_constructible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_nothrow_assignable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_nothrow_constructible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_nothrow_convertible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_nothrow_copy_assignable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_nothrow_copy_constructible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_nothrow_default_constructible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_nothrow_destructible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_nothrow_move_assignable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_nothrow_move_constructible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_null_pointer.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_object.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_pod.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_pointer.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_polymorphic.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_primary_template.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_reference.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_reference_wrapper.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_referenceable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_same.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_scalar.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_scoped_enum.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_signed.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_signed_integer.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_specialization.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_standard_layout.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_swappable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_trivial.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_trivially_assignable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_trivially_constructible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_trivially_copy_assignable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_trivially_copy_constructible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_trivially_copyable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_trivially_default_constructible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_trivially_destructible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_trivially_lexicographically_comparable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_trivially_move_assignable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_trivially_move_constructible.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_trivially_relocatable.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_unbounded_array.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_union.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_unsigned.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_unsigned_integer.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_valid_expansion.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_void.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/is_volatile.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/lazy.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/make_32_64_or_128_bit.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/make_const_lvalue_ref.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/make_signed.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/make_unsigned.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/maybe_const.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/nat.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/negation.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/noexcept_move_assign_container.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/operation_traits.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/promote.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/rank.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/remove_all_extents.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/remove_const.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/remove_const_ref.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/remove_cv.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/remove_cvref.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/remove_extent.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/remove_pointer.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/remove_reference.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/remove_volatile.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/result_of.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/strip_signature.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/type_identity.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/type_list.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/underlying_type.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/unwrap_ref.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__type_traits/void_t.h>", "private", "<type_traits>", "public" ] },
+  { include: [ "<__utility/as_const.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/as_lvalue.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/auto_cast.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/cmp.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/convert_to_integral.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/declval.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/empty.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/exception_guard.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/exchange.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/forward.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/forward_like.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/in_place.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/integer_sequence.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/is_pointer_in_range.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/move.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/no_destroy.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/pair.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/piecewise_construct.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/priority_tag.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/rel_ops.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/small_buffer.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/swap.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/to_underlying.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__utility/unreachable.h>", "private", "<utility>", "public" ] },
+  { include: [ "<__variant/monostate.h>", "private", "<variant>", "public" ] },
+]
diff --git a/libcxx/include/module.modulemap b/libcxx/include/module.modulemap
index 70dac2f19846b..9ac760408de99 100644
--- a/libcxx/include/module.modulemap
+++ b/libcxx/include/module.modulemap
@@ -1739,6 +1739,7 @@ module std_private_ranges_size                       [system] {
   export std_private_type_traits_make_unsigned
 }
 module std_private_ranges_split_view                 [system] { header "__ranges/split_view.h" }
+module std_private_ranges_stride_view                [system] { header "__ranges/stride_view.h" }
 module std_private_ranges_subrange                   [system] {
   header "__ranges/subrange.h"
   export std_private_ranges_subrange_fwd
diff --git a/libcxx/include/ranges b/libcxx/include/ranges
index 07a525ed8641f..d5a3fdc5b0999 100644
--- a/libcxx/include/ranges
+++ b/libcxx/include/ranges
@@ -408,6 +409,7 @@ namespace std {
 #  include <__ranges/single_view.h>
 #  include <__ranges/size.h>
 #  include <__ranges/split_view.h>
+#  include <__ranges/stride_view.h>
 #  include <__ranges/subrange.h>
 #  include <__ranges/take_view.h>
 #  include <__ranges/take_while_view.h>
diff --git a/libcxx/include/version b/libcxx/include/version
index 69556d731f1cf..99329898faf6e 100644
--- a/libcxx/include/version
+++ b/libcxx/include/version
@@ -189,6 +189,7 @@ __cpp_lib_ranges_join_with                              202202L <ranges>
 __cpp_lib_ranges_repeat                                 202207L <ranges>
 __cpp_lib_ranges_slide                                  202202L <ranges>
 __cpp_lib_ranges_starts_ends_with                       202106L <algorithm>
+__cpp_lib_ranges_stride                                 202207L <ranges>
 __cpp_lib_ranges_to_container                           202202L <ranges>
 __cpp_lib_ranges_zip                                    202110L <ranges> <tuple> <utility>
 __cpp_lib_ratio                                         202306L <ratio>
@@ -482,6 +483,7 @@ __cpp_lib_void_t                                        201411L <type_traits>
 # define __cpp_lib_ranges_repeat                        202207L
 // # define __cpp_lib_ranges_slide                         202202L
 # define __cpp_lib_ranges_starts_ends_with              202106L
+# define __cpp_lib_ranges_stride                        202207L
 # define __cpp_lib_ranges_to_container                  202202L
 // # define __cpp_lib_ranges_zip                           202110L
 // # define __cpp_lib_reference_from_temporary             202202L
diff --git a/libcxx/modules/std/ranges.inc b/libcxx/modules/std/ranges.inc
index f71efe948ede1..893e8a42aca95 100644
--- a/libcxx/modules/std/ranges.inc
+++ b/libcxx/modules/std/ranges.inc
@@ -334,14 +334,16 @@ export namespace std {
     }
 #endif // _LIBCPP_STD_VER >= 23
 
-#if 0
+#if _LIBCPP_STD_VER >= 23
     // [range.stride], stride view
     using std::ranges::stride_view;
 
     namespace views {
       using std::ranges::views::stride;
-    }
+    } // namespace views
+#endif // _LIBCPP_STD_VER >= 23
 
+#if 0
     using std::ranges::cartesian_product_view;
 
     namespace views {
diff --git a/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/ctor.assert.pass.cpp b/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/ctor.assert.pass.cpp
new file mode 100644
index 0000000000000..b62ce15d7c93b
--- /dev/null
+++ b/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/ctor.assert.pass.cpp
@@ -0,0 +1,27 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+// UNSUPPORTED: !libcpp-hardening-mode=debug
+// XFAIL: availability-verbose_abort-missing
+
+// constexpr explicit stride_view(_View, range_difference_t<_View>)
+
+#include <ranges>
+
+#include "check_assertion.h"
+
+int main(int, char**) {
+  int range[] = {1, 2, 3};
+  TEST_LIBCPP_ASSERT_FAILURE(
+      [&range] { std::ranges::stride_view sv(range, 0); }(), "The value of stride must be greater than 0");
+  TEST_LIBCPP_ASSERT_FAILURE(
+      [&range] { std::ranges::stride_view sv(range, -1); }(), "The value of stride must be greater than 0");
+
+  return 0;
+}
diff --git a/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/dereference.nodiscard.verify.cpp b/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/dereference.nodiscard.verify.cpp
new file mode 100644
index 0000000000000..d10a1aa2066a0
--- /dev/null
+++ b/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/dereference.nodiscard.verify.cpp
@@ -0,0 +1,24 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+// constexpr decltype(auto) operator*() const {
+
+#include <ranges>
+#include <utility>
+
+void test() {
+  {
+    int range[] = {1, 2, 3};
+    auto view   = std::ranges::views::stride(range, 3);
+    auto it     = view.begin();
+    ++it;
+    *std::as_const(it); // expected-warning {{ignoring return value of function declared with 'nodiscard' attribute}}
+  }
+}
diff --git a/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/dereference.pass.cpp b/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/dereference.pass.cpp
new file mode 100644
index 0000000000000..1c44078e52403
--- /dev/null
+++ b/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/dereference.pass.cpp
@@ -0,0 +1,34 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+// UNSUPPORTED: !libcpp-hardening-mode=debug
+// XFAIL: availability-verbose_abort-missing
+
+// constexpr decltype(auto) operator*() const
+
+#include "check_assertion.h"
+#include <ranges>
+
+int main(int, char**) {
+  {
+    int range[] = {1, 2, 3};
+    auto view   = std::ranges::views::stride(range, 3);
+    auto it     = view.begin();
+    ++it;
+    TEST_LIBCPP_ASSERT_FAILURE(*std::as_const(it), "Cannot dereference an iterator at the end.");
+  }
+  {
+    int range[] = {1, 2, 3};
+    auto view   = std::ranges::views::stride(range, 4);
+    auto it     = view.begin();
+    ++it;
+    TEST_LIBCPP_ASSERT_FAILURE(*std::as_const(it), "Cannot dereference an iterator at the end.");
+  }
+  return 0;
+}
diff --git a/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/increment.pass.cpp b/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/increment.pass.cpp
new file mode 100644
index 0000000000000..bd818ecc48b8e
--- /dev/null
+++ b/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/increment.pass.cpp
@@ -0,0 +1,45 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+// UNSUPPORTED: !libcpp-hardening-mode=debug
+// XFAIL: availability-verbose_abort-missing
+
+// constexpr stride_view::<iterator>& operator++()
+// constexpr __iterator& operator++()
+// constexpr void operator++(int) {
+// constexpr __iterator operator++(int)
+
+#include <ranges>
+
+#include "check_assertion.h"
+#include "test_iterators.h"
+
+#include "../../../../../std/ranges/range.adaptors/range.stride.view/types.h"
+
+int main(int, char**) {
+  {
+    int range[] = {1, 2, 3};
+    using Base  = BasicTestView<cpp17_input_iterator<int*>>;
+    auto view   = std::ranges::views::stride(Base(cpp17_input_iterator(range), cpp17_input_iterator(range + 3)), 3);
+    auto it     = view.begin();
+    ++it;
+    TEST_LIBCPP_ASSERT_FAILURE(it++, "Cannot increment an iterator already at the end.");
+    TEST_LIBCPP_ASSERT_FAILURE(++it, "Cannot increment an iterator already at the end.");
+  }
+  {
+    int range[] = {1, 2, 3};
+    using Base  = BasicTestView<forward_iterator<int*>, forward_iterator<int*>>;
+    auto view   = std::ranges::views::stride(Base(forward_iterator(range), forward_iterator(range + 3)), 3);
+    auto it     = view.begin();
+    ++it;
+    TEST_LIBCPP_ASSERT_FAILURE(it++, "Cannot increment an iterator already at the end.");
+    TEST_LIBCPP_ASSERT_FAILURE(++it, "Cannot increment an iterator already at the end.");
+  }
+  return 0;
+}
diff --git a/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/iter_move.nodiscard.verify.cpp b/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/iter_move.nodiscard.verify.cpp
new file mode 100644
index 0000000000000..9b2108a3361dd
--- /dev/null
+++ b/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/iter_move.nodiscard.verify.cpp
@@ -0,0 +1,36 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+// friend constexpr range_rvalue_reference_t<_Base> iter_move(__iterator const& __it) noexcept(noexcept(ranges::iter_move(__it.__current_)))
+
+#include <ranges>
+
+#include "../../../../../std/ranges/range.adaptors/range.stride.view/types.h"
+
+constexpr bool test() {
+  {
+    int a[] = {4, 3, 2, 1};
+
+    int iter_move_counter(0);
+    using View       = IterMoveIterSwapTestRange<int*, true, true>;
+    using StrideView = std::ranges::stride_view<View>;
+    auto svb         = StrideView(View(a, a + 4, &iter_move_counter), 1).begin();
+
+    static_assert(std::is_same_v<int, decltype(std::ranges::iter_move(svb))>);
+    static_assert(noexcept(std::ranges::iter_move(svb)));
+
+    // These lines need to be in sync so that clang-verify knows where the warning comes from.
+    // clang-format off
+    std::ranges::iter_move( // expected-warning {{ignoring return value of function declared with 'nodiscard' attribute}}
+        svb);
+    // clang-format on
+  }
+  return true;
+}
diff --git a/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/operator.nodiscard.verify.cpp b/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/operator.nodiscard.verify.cpp
new file mode 100644
index 0000000000000..18304d72e5965
--- /dev/null
+++ b/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/operator.nodiscard.verify.cpp
@@ -0,0 +1,58 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+// constexpr decltype(auto) operator[](difference_type __n) const
+
+#include <ranges>
+
+#include "../../../../../std/ranges/range.adaptors/range.stride.view/types.h"
+
+constexpr bool test_non_forward_operator_minus() {
+  int arr[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  using Base = BasicTestView<SizedInputIterator, SizedInputIterator>;
+
+  auto base_view_offset_zero             = Base(SizedInputIterator(arr), SizedInputIterator(arr + 10));
+  auto base_view_offset_one              = Base(SizedInputIterator(arr + 1), SizedInputIterator(arr + 10));
+  auto stride_view_over_base_zero_offset = std::ranges::stride_view(base_view_offset_zero, 3);
+  auto stride_view_over_base_one_offset  = std::ranges::stride_view(base_view_offset_one, 3);
+
+  auto sv_zero_offset_begin = stride_view_over_base_zero_offset.begin();
+  auto sv_one_offset_begin  = stride_view_over_base_one_offset.begin();
+
+  sv_one_offset_begin - // expected-warning {{ignoring return value of function declared with 'nodiscard' attribute}}
+      sv_zero_offset_begin;
+  return true;
+}
+
+constexpr bool test_forward_operator_minus() {
+  // Test the forward-range operator- between two iterators (i.e., no ceil).
+  using Base = BasicTestView<int*, int*>;
+  int arr[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  auto base_view_offset_zero             = Base(arr, arr + 10);
+  auto base_view_offset_one              = Base(arr + 1, arr + 10);
+  auto stride_view_over_base_zero_offset = std::ranges::stride_view(base_view_offset_zero, 3);
+  auto stride_view_over_base_one_offset  = std::ranges::stride_view(base_view_offset_one, 3);
+
+  auto sv_zero_offset_begin = stride_view_over_base_zero_offset.begin();
+  auto sv_one_offset_begin  = stride_view_over_base_one_offset.begin();
+
+  sv_zero_offset_begin + // expected-warning {{ignoring return value of function declared with 'nodiscard' attribute}}
+      1;
+  1 + sv_zero_offset_begin; // expected-warning {{ignoring return value of function declared with 'nodiscard' attribute}}
+
+  sv_one_offset_begin - 1; // expected-warning {{ignoring return value of function declared with 'nodiscard' attribute}}
+
+  sv_one_offset_begin - // expected-warning {{ignoring return value of function declared with 'nodiscard' attribute}}
+      sv_zero_offset_begin;
+
+  return true;
+}
diff --git a/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/operator_plus_equal.pass.cpp b/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/operator_plus_equal.pass.cpp
new file mode 100644
index 0000000000000..766d99223dc8d
--- /dev/null
+++ b/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/operator_plus_equal.pass.cpp
@@ -0,0 +1,26 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+// UNSUPPORTED: !libcpp-hardening-mode=debug
+// XFAIL: availability-verbose_abort-missing
+
+// constexpr __iterator& operator+=(difference_type __n)
+
+#include <ranges>
+
+#include "check_assertion.h"
+
+int main(int, char**) {
+  int range[] = {1, 2, 3};
+  auto view   = std::ranges::views::stride(range, 2);
+  auto it     = view.begin();
+  TEST_LIBCPP_ASSERT_FAILURE(it += 3, "Advancing the iterator beyond the end is not allowed.");
+
+  return 0;
+}
diff --git a/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/subscript.nodiscard.verify.cpp b/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/subscript.nodiscard.verify.cpp
new file mode 100644
index 0000000000000..cfd048b66afe4
--- /dev/null
+++ b/libcxx/test/libcxx/ranges/range.adaptors/range.stride.view/iterator/subscript.nodiscard.verify.cpp
@@ -0,0 +1,22 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+// constexpr decltype(auto) operator[](difference_type __n) const
+
+#include <ranges>
+
+void test() {
+  {
+    int range[] = {1, 2, 3};
+    auto view   = std::ranges::views::stride(range, 3);
+    auto it     = view.begin();
+    it[0]; // expected-warning {{ignoring return value of function declared with 'nodiscard' attribute}}
+  }
+}
diff --git a/libcxx/test/std/language.support/support.limits/support.limits.general/ranges.version.compile.pass.cpp b/libcxx/test/std/language.support/support.limits/support.limits.general/ranges.version.compile.pass.cpp
index 30feacd796d8e..70c9f9214977a 100644
--- a/libcxx/test/std/language.support/support.limits/support.limits.general/ranges.version.compile.pass.cpp
+++ b/libcxx/test/std/language.support/support.limits/support.limits.general/ranges.version.compile.pass.cpp
@@ -26,6 +26,7 @@
     __cpp_lib_ranges_join_with                              202202L [C++23]
     __cpp_lib_ranges_repeat                                 202207L [C++23]
     __cpp_lib_ranges_slide                                  202202L [C++23]
+    __cpp_lib_ranges_stride                                 202207L [C++23]
     __cpp_lib_ranges_to_container                           202202L [C++23]
     __cpp_lib_ranges_zip                                    202110L [C++23]
 */
@@ -75,6 +76,10 @@
 #   error "__cpp_lib_ranges_slide should not be defined before c++23"
 # endif
 
+# ifdef __cpp_lib_ranges_stride
+#   error "__cpp_lib_ranges_stride should not be defined before c++23"
+# endif
+
 # ifdef __cpp_lib_ranges_to_container
 #   error "__cpp_lib_ranges_to_container should not be defined before c++23"
 # endif
@@ -125,6 +130,10 @@
 #   error "__cpp_lib_ranges_slide should not be defined before c++23"
 # endif
 
+# ifdef __cpp_lib_ranges_stride
+#   error "__cpp_lib_ranges_stride should not be defined before c++23"
+# endif
+
 # ifdef __cpp_lib_ranges_to_container
 #   error "__cpp_lib_ranges_to_container should not be defined before c++23"
 # endif
@@ -175,6 +184,10 @@
 #   error "__cpp_lib_ranges_slide should not be defined before c++23"
 # endif
 
+# ifdef __cpp_lib_ranges_stride
+#   error "__cpp_lib_ranges_stride should not be defined before c++23"
+# endif
+
 # ifdef __cpp_lib_ranges_to_container
 #   error "__cpp_lib_ranges_to_container should not be defined before c++23"
 # endif
@@ -228,6 +241,10 @@
 #   error "__cpp_lib_ranges_slide should not be defined before c++23"
 # endif
 
+# ifdef __cpp_lib_ranges_stride
+#   error "__cpp_lib_ranges_stride should not be defined before c++23"
+# endif
+
 # ifdef __cpp_lib_ranges_to_container
 #   error "__cpp_lib_ranges_to_container should not be defined before c++23"
 # endif
@@ -326,6 +343,13 @@
 #   endif
 # endif
 
+# ifndef __cpp_lib_ranges_stride
+#   error "__cpp_lib_ranges_stride should be defined in c++23"
+# endif
+# if __cpp_lib_ranges_stride != 202207L
+#   error "__cpp_lib_ranges_stride should have the value 202207L in c++23"
+# endif
+
 # ifndef __cpp_lib_ranges_to_container
 #   error "__cpp_lib_ranges_to_container should be defined in c++23"
 # endif
@@ -454,6 +478,13 @@
 #   endif
 # endif
 
+# ifndef __cpp_lib_ranges_stride
+#   error "__cpp_lib_ranges_stride should be defined in c++26"
+# endif
+# if __cpp_lib_ranges_stride != 202207L
+#   error "__cpp_lib_ranges_stride should have the value 202207L in c++26"
+# endif
+
 # ifndef __cpp_lib_ranges_to_container
 #   error "__cpp_lib_ranges_to_container should be defined in c++26"
 # endif
diff --git a/libcxx/test/std/ranges/range.adaptors/range.as.rvalue/enable_borrowed_range.compile.pass.cpp b/libcxx/test/std/ranges/range.adaptors/range.as.rvalue/enable_borrowed_range.compile.pass.cpp
index 48d1d96b02482..3859f5ad3dee8 100644
--- a/libcxx/test/std/ranges/range.adaptors/range.as.rvalue/enable_borrowed_range.compile.pass.cpp
+++ b/libcxx/test/std/ranges/range.adaptors/range.as.rvalue/enable_borrowed_range.compile.pass.cpp
@@ -11,6 +11,11 @@
 #include <ranges>
 #include <vector>
 
+static_assert(std::ranges::enable_borrowed_range<std::ranges::empty_view<int>>);
 static_assert(std::ranges::enable_borrowed_range<std::ranges::as_rvalue_view<std::ranges::empty_view<int>>>);
+
+static_assert(std::ranges::enable_borrowed_range<std::views::all_t<std::vector<int>&>>);
 static_assert(std::ranges::enable_borrowed_range<std::ranges::as_rvalue_view<std::views::all_t<std::vector<int>&>>>);
+
+static_assert(!std::ranges::enable_borrowed_range<std::views::all_t<std::vector<int>>>);
 static_assert(!std::ranges::enable_borrowed_range<std::ranges::as_rvalue_view<std::views::all_t<std::vector<int>>>>);
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/adaptor.pass.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/adaptor.pass.cpp
new file mode 100644
index 0000000000000..ea7fd588fd81f
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/adaptor.pass.cpp
@@ -0,0 +1,147 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+// std::views::stride_view
+
+#include <ranges>
+
+#include "test_iterators.h"
+#include "types.h"
+
+constexpr BasicTestView<cpp17_input_iterator<int*>> make_input_view(int* begin, int* end) {
+  return BasicTestView<cpp17_input_iterator<int*>>(cpp17_input_iterator<int*>(begin), cpp17_input_iterator<int*>(end));
+}
+
+using ForwardStrideView      = std::ranges::stride_view<BasicTestView<forward_iterator<int*>>>;
+using BidirStrideView        = std::ranges::stride_view<BasicTestView<bidirectional_iterator<int*>>>;
+using RandomAccessStrideView = std::ranges::stride_view<BasicTestView<random_access_iterator<int*>>>;
+
+using SizedForwardStrideView =
+    std::ranges::stride_view<BasicTestView<random_access_iterator<int*>, random_access_iterator<int*>>>;
+using SizedInputStrideView = std::ranges::stride_view<BasicTestView<SizedInputIterator, SizedInputIterator>>;
+
+static_assert(std::ranges::forward_range<ForwardStrideView>);
+static_assert(std::ranges::bidirectional_range<BidirStrideView>);
+static_assert(std::ranges::random_access_range<RandomAccessStrideView>);
+static_assert(std::ranges::forward_range<SizedForwardStrideView>);
+static_assert(std::sized_sentinel_for<std::ranges::iterator_t<SizedForwardStrideView>,
+                                      std::ranges::iterator_t<SizedForwardStrideView>>);
+static_assert(std::sized_sentinel_for<std::ranges::iterator_t<SizedInputStrideView>,
+                                      std::ranges::iterator_t<SizedInputStrideView>>);
+
+constexpr bool test() {
+  constexpr int N = 3;
+  int arr[N]      = {1, 2, 3};
+
+  // Test that `std::views::stride` is a range adaptor.
+  // Check various forms of
+
+  // view | stride
+  // two tests: first with stride of 1; second with stride of 2.
+  {
+    using View                                                          = BasicTestView<cpp17_input_iterator<int*>>;
+    auto view                                                           = make_input_view(arr, arr + N);
+    std::same_as<std::ranges::stride_view<View>> decltype(auto) strided = view | std::views::stride(1);
+    auto strided_iter                                                   = strided.begin();
+
+    // Check that the begin() iter views arr[0]
+    assert(*strided_iter == arr[0]);
+
+    // Check that the strided_iter, after advancing it 2 * 1 steps, views arr[2].
+    std::ranges::advance(strided_iter, 2);
+    assert(*strided_iter == arr[2]);
+  }
+  {
+    using View                                                          = BasicTestView<cpp17_input_iterator<int*>>;
+    auto view                                                           = make_input_view(arr, arr + N);
+    std::same_as<std::ranges::stride_view<View>> decltype(auto) strided = view | std::views::stride(2);
+    auto strided_iter                                                   = strided.begin();
+
+    assert(*strided_iter == arr[0]);
+    std::ranges::advance(strided_iter, 1);
+    assert(*strided_iter == arr[2]);
+  }
+
+  // adaptor | stride
+  // two tests: first with stride of 1; second with stride of 2.
+  const auto i2 = [](int i) { return i * 2; };
+  {
+    auto view                           = make_input_view(arr, arr + N);
+    const auto transform_stride_partial = std::views::transform(i2) | std::views::stride(1);
+
+    auto transform_stride_applied      = transform_stride_partial(view);
+    auto transform_stride_applied_iter = transform_stride_applied.begin();
+
+    assert(*transform_stride_applied_iter == i2(arr[0]));
+    std::ranges::advance(transform_stride_applied_iter, 2);
+    assert(*transform_stride_applied_iter == i2(arr[2]));
+  }
+
+  {
+    auto view                           = make_input_view(arr, arr + N);
+    const auto transform_stride_partial = std::views::transform(i2) | std::views::stride(2);
+
+    const auto transform_stride_applied = transform_stride_partial(view);
+    auto transform_stride_applied_iter  = transform_stride_applied.begin();
+
+    assert(*transform_stride_applied_iter == i2(arr[0]));
+    std::ranges::advance(transform_stride_applied_iter, 1);
+    assert(*transform_stride_applied_iter == i2(arr[2]));
+  }
+
+  // stride | adaptor
+  // two tests: first with stride of 1; second with stride of 2.
+  {
+    auto view                   = make_input_view(arr, arr + N);
+    const auto stride_transform = std::views::stride(view, 1) | std::views::transform(i2);
+
+    auto stride_transform_iter = stride_transform.begin();
+
+    assert(*stride_transform_iter == i2(arr[0]));
+    std::ranges::advance(stride_transform_iter, 2);
+    assert(*stride_transform_iter == i2(arr[2]));
+  }
+  {
+    auto view                   = make_input_view(arr, arr + N);
+    const auto stride_transform = std::views::stride(view, 2) | std::views::transform(i2);
+
+    auto stride_transform_iter = stride_transform.begin();
+
+    assert(*stride_transform_iter == i2(arr[0]));
+    std::ranges::advance(stride_transform_iter, 1);
+    assert(*stride_transform_iter == i2(arr[2]));
+  }
+
+  // Check SFINAE friendliness
+  {
+    struct NotAViewableRange {};
+    using View = BasicTestView<bidirectional_iterator<int*>>;
+
+    static_assert(!std::is_invocable_v<decltype(std::views::stride)>);
+    static_assert(!std::is_invocable_v<decltype(std::views::stride), NotAViewableRange, int>);
+
+    static_assert(CanBePiped<View, decltype(std::views::stride(5))>);
+    static_assert(CanBePiped<View&, decltype(std::views::stride(5))>);
+    static_assert(!CanBePiped<NotAViewableRange, decltype(std::views::stride(5))>);
+    static_assert(!CanBePiped<View&, decltype(std::views::stride(NotAViewableRange{}))>);
+  }
+
+  // A final sanity check.
+  { static_assert(std::same_as<decltype(std::views::stride), decltype(std::ranges::views::stride)>); }
+
+  return true;
+}
+
+int main(int, char**) {
+  test();
+  static_assert(test());
+
+  return 0;
+}
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/base.pass.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/base.pass.cpp
new file mode 100644
index 0000000000000..c335c038eea4c
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/base.pass.cpp
@@ -0,0 +1,57 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+// constexpr _View base() const& requires copy_constructible<_View>;
+// constexpr _View base() &&;
+
+#include <cassert>
+#include <ranges>
+
+#include "test_iterators.h"
+#include "types.h"
+
+template <typename T>
+constexpr bool hasLValueQualifiedBase(T&& t) {
+  return requires { t.base(); };
+}
+
+constexpr bool test() {
+  int buff[]      = {1, 2, 3, 4, 5, 6, 7, 8};
+  constexpr int N = 8;
+  {
+    using CopyableInputView = CopyableView<cpp17_input_iterator<int*>>;
+    auto str(std::ranges::stride_view<CopyableInputView>(
+        CopyableInputView(cpp17_input_iterator<int*>(buff), cpp17_input_iterator<int*>(buff + N)), 1));
+    assert(*str.base().begin() == *buff);
+    assert(*(std::move(str)).base().begin() == *buff);
+
+    ASSERT_SAME_TYPE(decltype(str.base()), CopyableInputView);
+    ASSERT_SAME_TYPE(decltype(std::move(str).base()), CopyableInputView);
+    static_assert(hasLValueQualifiedBase(str));
+  }
+
+  {
+    using MoveOnlyInputView = MoveOnlyView<cpp17_input_iterator<int*>>;
+    auto str(std::ranges::stride_view<MoveOnlyInputView>(
+        MoveOnlyInputView(cpp17_input_iterator<int*>(buff), cpp17_input_iterator<int*>(buff + N)), 1));
+    assert(*(std::move(str)).base().begin() == *buff);
+
+    ASSERT_SAME_TYPE(decltype(std::move(str).base()), MoveOnlyInputView);
+    static_assert(!hasLValueQualifiedBase(str));
+  }
+  return true;
+}
+
+int main(int, char**) {
+  test();
+  static_assert(test());
+
+  return 0;
+}
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/begin.pass.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/begin.pass.cpp
new file mode 100644
index 0000000000000..b2c73db27905c
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/begin.pass.cpp
@@ -0,0 +1,48 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+// constexpr auto begin() requires(!__simple_view<_View>)
+// constexpr auto begin() const requires range<const _View>
+
+// Note: Checks here are augmented by checks in
+// iterator/ctor.copy.pass.cpp.
+
+#include <ranges>
+
+#include "types.h"
+
+template <class T>
+concept HasConstBegin = requires(const T& ct) { ct.begin(); };
+
+template <class T>
+concept HasBegin = requires(T& t) { t.begin(); };
+
+template <class T>
+concept HasConstAndNonConstBegin = HasConstBegin<T> && requires(T& t, const T& ct) {
+  requires !std::same_as<decltype(t.begin()), decltype(ct.begin())>;
+};
+
+template <class T>
+concept HasOnlyNonConstBegin = HasBegin<T> && !HasConstBegin<T>;
+
+template <class T>
+concept HasOnlyConstBegin = HasConstBegin<T> && !HasConstAndNonConstBegin<T>;
+
+static_assert(HasOnlyNonConstBegin<std::ranges::stride_view<UnSimpleNoConstCommonView>>);
+static_assert(HasOnlyConstBegin<std::ranges::stride_view<BasicTestView<int*, int*>>>);
+static_assert(HasConstAndNonConstBegin<std::ranges::stride_view<UnsimpleConstView>>);
+
+int main(int, char**) {
+  int buffer[] = {1, 2, 3};
+  auto sv      = std::ranges::stride_view(BasicTestView<int*, int*>(buffer, buffer + 3), 1);
+  assert(1 == *(sv.begin()));
+
+  return 0;
+}
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/borrowing.compile.pass.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/borrowing.compile.pass.cpp
new file mode 100644
index 0000000000000..4c2d0efb774b2
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/borrowing.compile.pass.cpp
@@ -0,0 +1,21 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+// template<class V>
+// inline constexpr bool enable_borrowed_range<stride_view<V>> = ranges::enable_borrowed_range<V>;
+
+#include <ranges>
+#include <vector>
+
+#include "types.h"
+#include "test_range.h"
+
+static_assert(std::ranges::enable_borrowed_range< std::ranges::stride_view<BorrowedView>>);
+static_assert(!std::ranges::enable_borrowed_range< std::ranges::stride_view<NonBorrowedView>>);
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/concept.verify.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/concept.verify.cpp
new file mode 100644
index 0000000000000..a17960017ce1c
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/concept.verify.cpp
@@ -0,0 +1,43 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+// expected-no-diagnostics
+
+// template <input_range _View> requires view<_View>
+
+#include "__ranges/stride_view.h"
+#include "almost_satisfies_types.h"
+#include "test_iterators.h"
+#include "test_range.h"
+#include "types.h"
+
+template <typename I, std::ranges::range_difference_t<I> D>
+concept CanStrideView = requires { std::ranges::stride_view<I>{I{}, D}; };
+
+// Ensure that the InputRangeNotIndirectlyReadable is a valid range.
+static_assert(std::ranges::range<InputRangeNotIndirectlyReadable>);
+// Ensure that the InputRangeNotIndirectlyReadable's is not an input range ...
+static_assert(!std::ranges::input_range<std::ranges::iterator_t<InputRangeNotIndirectlyReadable>>);
+// Because CanStrideView requires that the range/view type be default constructible, let's double check that ...
+static_assert(std::is_constructible_v<InputRangeNotIndirectlyReadable>);
+// And now, finally, let's make sure that we cannot stride over a range whose iterator is not an input iterator ...
+static_assert(!CanStrideView<InputRangeNotIndirectlyReadable, 1>);
+
+// Ensure that a range that is not a view cannot be the subject of a stride_view.
+static_assert(std::ranges::range<test_non_const_range<cpp17_input_iterator>>);
+static_assert(std::ranges::input_range<test_non_const_range<cpp17_input_iterator>>);
+static_assert(std::movable<test_non_const_range<cpp17_input_iterator>>);
+static_assert(!std::ranges::view<test_non_const_range<cpp17_input_iterator>>);
+static_assert(!CanStrideView<test_non_const_range<cpp17_input_iterator>, 1>);
+
+// And now, let's satisfy all the prerequisites and make sure that we can stride over a range (that is an input range and is a view!)
+static_assert(std::ranges::range<test_view<cpp17_input_iterator>>);
+static_assert(std::ranges::input_range<test_view<cpp17_input_iterator>>);
+static_assert(std::ranges::view<test_view<cpp17_input_iterator>>);
+static_assert(CanStrideView<test_view<cpp17_input_iterator>, 1>);
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/ctad.pass.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/ctad.pass.cpp
new file mode 100644
index 0000000000000..d8f19116810c8
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/ctad.pass.cpp
@@ -0,0 +1,93 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+// template <class _Range>
+// stride_view(_Range&&, range_difference_t<_Range>) -> stride_view<views::all_t<_Range>>;
+
+#include "types.h"
+#include <concepts>
+#include <ranges>
+
+struct View : std::ranges::view_base {
+  int* begin() const;
+  int* end() const;
+};
+
+struct Range {
+  int* begin() const;
+  int* end() const;
+};
+
+constexpr bool testCTAD() {
+  int a[] = {1, 2, 3, 4, 5};
+
+  using BaseRange = BasicTestRange<cpp17_input_iterator<int*>>;
+  using BaseView  = BasicTestView<int*>;
+
+  auto base_view  = BaseView(a, a + 5);
+  auto base_range = BaseRange(cpp17_input_iterator<int*>(a), cpp17_input_iterator<int*>(a + 5));
+
+  auto copied_stride_base_view = std::ranges::stride_view(base_view, 2);
+  auto moved_stride_base_view  = std::ranges::stride_view(std::move(base_view), 2);
+
+  auto copied_stride_base_range = std::ranges::stride_view(base_range, 2);
+  auto moved_stride_base_range  = std::ranges::stride_view(std::move(base_range), 2);
+
+  static_assert(std::same_as< decltype(copied_stride_base_view), std::ranges::stride_view<BaseView>>);
+  static_assert(std::same_as< decltype(moved_stride_base_view), std::ranges::stride_view<BaseView>>);
+
+  static_assert(
+      std::same_as< decltype(copied_stride_base_range), std::ranges::stride_view<std::ranges::ref_view<BaseRange>> >);
+  static_assert(
+      std::same_as< decltype(moved_stride_base_range), std::ranges::stride_view<std::ranges::owning_view<BaseRange>> >);
+
+  assert(*copied_stride_base_range.begin() == 1);
+  assert(*moved_stride_base_range.begin() == 1);
+
+  assert(*copied_stride_base_view.begin() == 1);
+  assert(*moved_stride_base_view.begin() == 1);
+
+  auto copied_stride_range_it = copied_stride_base_range.begin();
+  copied_stride_range_it++;
+  assert(*copied_stride_range_it == 3);
+  copied_stride_range_it++;
+  copied_stride_range_it++;
+  assert(copied_stride_range_it == copied_stride_base_range.end());
+
+  auto moved_stride_range_it = moved_stride_base_range.begin();
+  moved_stride_range_it++;
+  moved_stride_range_it++;
+  assert(*moved_stride_range_it == 5);
+  moved_stride_range_it++;
+  assert(moved_stride_range_it == moved_stride_base_range.end());
+
+  auto copied_stride_view_it = copied_stride_base_view.begin();
+  copied_stride_view_it++;
+  assert(*copied_stride_view_it == 3);
+  copied_stride_view_it++;
+  copied_stride_view_it++;
+  assert(copied_stride_view_it == copied_stride_base_view.end());
+
+  auto moved_stride_view_it = copied_stride_base_view.begin();
+  moved_stride_view_it++;
+  moved_stride_view_it++;
+  assert(*moved_stride_view_it == 5);
+  moved_stride_view_it++;
+  assert(moved_stride_view_it == moved_stride_base_view.end());
+
+  return true;
+}
+
+int main(int, char**) {
+  testCTAD();
+  static_assert(testCTAD());
+
+  return 0;
+}
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/ctor.pass.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/ctor.pass.cpp
new file mode 100644
index 0000000000000..3207565e4c5bf
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/ctor.pass.cpp
@@ -0,0 +1,61 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+// constexpr explicit stride_view(_View, range_difference_t<_View>)
+
+#include <type_traits>
+
+#include "test_convertible.h"
+#include "test_iterators.h"
+#include "types.h"
+
+// There is no default ctor for stride_view.
+using View = BasicTestView<cpp17_input_iterator<int*>>;
+static_assert(!std::is_default_constructible_v<std::ranges::stride_view<View>>);
+
+// Test that the stride_view can only be explicitly constructed.
+static_assert(!test_convertible<std::ranges::stride_view<View>, View, int>());
+
+constexpr bool test() {
+  {
+    int arr[] = {1, 2, 3};
+    // Test that what we will stride over is move only.
+    static_assert(!std::is_copy_constructible_v<MoveOnlyView<cpp17_input_iterator<int*>>>);
+    static_assert(std::is_move_constructible_v<MoveOnlyView<cpp17_input_iterator<int*>>>);
+
+    MoveOnlyView<cpp17_input_iterator<int*>> mov(cpp17_input_iterator<int*>(arr), cpp17_input_iterator<int*>(arr + 3));
+    // Because MoveOnlyView is, well, move only, we can test that it is moved
+    // from when the stride view is constructed.
+    std::ranges::stride_view<MoveOnlyView<cpp17_input_iterator<int*>>> mosv(std::move(mov), 1);
+
+    // While we are here, make sure that the ctor captured the proper things
+    assert(mosv.stride() == 1);
+
+    auto mosv_i = mosv.begin();
+    assert(*mosv_i == 1);
+
+    mosv_i++;
+    assert(*mosv_i == 2);
+
+    mosv_i++;
+    assert(*mosv_i == 3);
+
+    mosv_i++;
+    assert(mosv_i == mosv.end());
+  }
+  return true;
+}
+
+int main(int, char**) {
+  test();
+  static_assert(test());
+
+  return 0;
+}
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/end.pass.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/end.pass.cpp
new file mode 100644
index 0000000000000..06405a9fc5994
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/end.pass.cpp
@@ -0,0 +1,100 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+// constexpr auto end() requires(!__simple_view<_View>)
+// constexpr auto end() const requires(range<const _View>)
+
+// Note: Checks here are augmented by checks in
+// iterator/ctor.copy.pass.cpp.
+
+#include <ranges>
+
+#include "types.h"
+
+template <class T>
+concept HasConstEnd = requires(const T& ct) { ct.end(); };
+
+template <class T>
+concept HasEnd = requires(T& t) { t.end(); };
+
+template <class T>
+concept HasConstAndNonConstEnd =
+    HasConstEnd<T> && requires(T& t, const T& ct) { requires !std::same_as<decltype(t.end()), decltype(ct.end())>; };
+
+template <class T>
+concept HasOnlyNonConstEnd = HasEnd<T> && !HasConstEnd<T>;
+
+template <class T>
+concept HasOnlyConstEnd = HasConstEnd<T> && !HasConstAndNonConstEnd<T>;
+
+static_assert(HasOnlyNonConstEnd<std::ranges::stride_view<UnSimpleNoConstCommonView>>);
+static_assert(HasOnlyConstEnd<std::ranges::stride_view<BasicTestView<int*, int*>>>);
+static_assert(HasConstAndNonConstEnd<std::ranges::stride_view<UnsimpleConstView>>);
+
+static_assert(simple_view<SimpleUnCommonConstView>);
+static_assert(!std::ranges::common_range<SimpleUnCommonConstView>);
+
+constexpr bool test_non_default_sentinel() {
+  {
+    static_assert(simple_view<BasicTestView<int*, int*>>);
+    static_assert(std::ranges::common_range<BasicTestView<int*, int*>>);
+    static_assert(std::ranges::sized_range<BasicTestView<int*, int*>>);
+    static_assert(std::ranges::forward_range<BasicTestView<int*, int*>>);
+
+    auto v  = BasicTestView<int*, int*>{nullptr, nullptr};
+    auto sv = std::ranges::stride_view<BasicTestView<int*, int*>>(v, 1);
+    static_assert(!std::is_same_v<std::default_sentinel_t, decltype(sv.end())>);
+  }
+
+  {
+    static_assert(!simple_view<UnSimpleNoConstCommonView>);
+    static_assert(std::ranges::common_range<UnSimpleNoConstCommonView>);
+    static_assert(std::ranges::sized_range<UnSimpleNoConstCommonView>);
+    static_assert(std::ranges::forward_range<UnSimpleNoConstCommonView>);
+
+    auto v  = UnSimpleNoConstCommonView{};
+    auto sv = std::ranges::stride_view<UnSimpleNoConstCommonView>(v, 1);
+    static_assert(!std::is_same_v<std::default_sentinel_t, decltype(sv.end())>);
+  }
+  return true;
+}
+
+constexpr bool test_default_sentinel() {
+  {
+    static_assert(!simple_view<UnsimpleUnCommonConstView>);
+    static_assert(!std::ranges::common_range<UnsimpleUnCommonConstView>);
+    static_assert(std::ranges::sized_range<UnsimpleConstView>);
+    static_assert(std::ranges::forward_range<UnsimpleConstView>);
+
+    auto v  = UnsimpleUnCommonConstView{};
+    auto sv = std::ranges::stride_view<UnsimpleUnCommonConstView>(v, 1);
+    ASSERT_SAME_TYPE(std::default_sentinel_t, decltype(sv.end()));
+  }
+
+  {
+    static_assert(simple_view<SimpleUnCommonConstView>);
+    static_assert(!std::ranges::common_range<SimpleUnCommonConstView>);
+
+    auto v  = SimpleUnCommonConstView{};
+    auto sv = std::ranges::stride_view<SimpleUnCommonConstView>(v, 1);
+
+    ASSERT_SAME_TYPE(std::default_sentinel_t, decltype(sv.end()));
+  }
+  return true;
+}
+
+int main(int, char**) {
+  test_non_default_sentinel();
+  test_default_sentinel();
+  static_assert(test_non_default_sentinel());
+  static_assert(test_default_sentinel());
+
+  return 0;
+}
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/base.pass.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/base.pass.cpp
new file mode 100644
index 0000000000000..f007ffcf84d6e
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/base.pass.cpp
@@ -0,0 +1,56 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+// constexpr iterator_t<_Base> const& base() const& noexcept
+// constexpr iterator_t<_Base> base() &&
+
+#include <ranges>
+#include <type_traits>
+
+#include "../types.h"
+
+constexpr bool base_noexcept() {
+  {
+    int arr[]                         = {1, 2, 3};
+    auto stride                       = std::ranges::stride_view(arr, 1);
+    [[maybe_unused]] auto stride_iter = stride.begin();
+
+    // Check that calling base on an iterator where this is an lvalue reference
+    // is noexcept.
+    static_assert(noexcept(stride_iter.base()));
+    // Calling base on an iterator where this is an rvalue reference may except.
+    static_assert(!noexcept((std::move(stride_iter).base())));
+  }
+
+  return true;
+}
+
+constexpr bool base_const() {
+  {
+    int arr[]                         = {1, 2, 3};
+    auto stride                       = std::ranges::stride_view(arr, 1);
+    [[maybe_unused]] auto stride_iter = stride.begin();
+
+    // Calling base on an iterator where this is lvalue returns a const ref to an iterator.
+    static_assert(std::is_const_v<std::remove_reference_t<decltype(stride_iter.base())>>);
+    // Calling base on an iterator where this is an rvalue reference returns a non-const iterator.
+    static_assert(!std::is_const_v<decltype(std::move(stride_iter).base())>);
+  }
+
+  return true;
+}
+int main(int, char**) {
+  base_noexcept();
+  static_assert(base_noexcept());
+  base_const();
+  static_assert(base_const());
+
+  return 0;
+}
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/ctor.copy.pass.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/ctor.copy.pass.cpp
new file mode 100644
index 0000000000000..cea97fe49ecef
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/ctor.copy.pass.cpp
@@ -0,0 +1,376 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+// constexpr __iterator(__iterator<!_Const> __i)
+//    requires _Const && convertible_to<ranges::iterator_t<_View>, iterator_t<_Base>> &&
+//                 convertible_to<sentinel_t<_View>, sentinel_t<_Base>>
+
+#include <iterator>
+#include <ranges>
+
+#include "../types.h"
+#include "test_iterators.h"
+#include "test_macros.h"
+
+struct NotSimpleViewIterEnd;
+template <bool, bool>
+struct NotSimpleViewConstIterEnd;
+template <bool, bool>
+struct NotSimpleViewConstIterBegin;
+
+struct NotSimpleViewIterBegin : InputIterBase<NotSimpleViewIterBegin> {
+  template <bool CopyConvertible, bool MoveConvertible>
+  friend constexpr bool
+  operator==(const NotSimpleViewIterBegin&, const NotSimpleViewConstIterEnd<CopyConvertible, MoveConvertible>&) {
+    return true;
+  }
+  template <bool CopyConvertible, bool MoveConvertible>
+  friend constexpr bool
+  operator==(const NotSimpleViewIterBegin&, const NotSimpleViewConstIterBegin<CopyConvertible, MoveConvertible>&) {
+    return true;
+  }
+};
+
+template <bool CopyConvertible, bool MoveConvertible>
+struct NotSimpleViewConstIterBegin : InputIterBase<NotSimpleViewConstIterBegin<CopyConvertible, MoveConvertible>> {
+  constexpr NotSimpleViewConstIterBegin()                                              = default;
+  constexpr NotSimpleViewConstIterBegin(NotSimpleViewConstIterBegin&&)                 = default;
+  constexpr NotSimpleViewConstIterBegin& operator=(const NotSimpleViewConstIterBegin&) = default;
+  constexpr NotSimpleViewConstIterBegin& operator=(NotSimpleViewConstIterBegin&&)      = default;
+
+  constexpr NotSimpleViewConstIterBegin(const NotSimpleViewConstIterBegin&) {}
+  constexpr NotSimpleViewConstIterBegin(const NotSimpleViewIterBegin&)
+    requires CopyConvertible
+  {}
+  constexpr NotSimpleViewConstIterBegin(NotSimpleViewIterBegin&&)
+    requires MoveConvertible
+  {}
+
+  friend constexpr bool
+  operator==(const NotSimpleViewConstIterBegin<CopyConvertible, MoveConvertible>&, const NotSimpleViewIterEnd&) {
+    return true;
+  }
+  friend constexpr bool
+  operator==(const NotSimpleViewConstIterBegin<CopyConvertible, MoveConvertible>&, const NotSimpleViewIterBegin&) {
+    return true;
+  }
+};
+
+struct NotSimpleViewIterEnd : InputIterBase<NotSimpleViewIterEnd> {
+  template <bool CopyConvertible, bool MoveConvertible>
+  friend constexpr bool
+  operator==(const NotSimpleViewIterEnd&, const NotSimpleViewConstIterBegin<CopyConvertible, MoveConvertible>&) {
+    return true;
+  }
+  template <bool CopyConvertible, bool MoveConvertible>
+  friend constexpr bool
+  operator==(const NotSimpleViewIterEnd&, const NotSimpleViewConstIterEnd<CopyConvertible, MoveConvertible>&) {
+    return true;
+  }
+
+  friend constexpr bool operator==(const NotSimpleViewIterEnd&, const NotSimpleViewIterBegin&) { return true; }
+};
+
+template <bool CopyConvertible, bool MoveConvertible>
+struct NotSimpleViewConstIterEnd : InputIterBase<NotSimpleViewConstIterEnd<CopyConvertible, MoveConvertible>> {
+  constexpr NotSimpleViewConstIterEnd()                                            = default;
+  constexpr NotSimpleViewConstIterEnd(NotSimpleViewConstIterEnd&&)                 = default;
+  constexpr NotSimpleViewConstIterEnd& operator=(const NotSimpleViewConstIterEnd&) = default;
+  constexpr NotSimpleViewConstIterEnd& operator=(NotSimpleViewConstIterEnd&&)      = default;
+
+  constexpr NotSimpleViewConstIterEnd(const NotSimpleViewConstIterEnd&) {}
+  constexpr NotSimpleViewConstIterEnd(const NotSimpleViewIterEnd&)
+    requires CopyConvertible
+  {}
+  constexpr NotSimpleViewConstIterEnd(NotSimpleViewIterEnd&&)
+    requires MoveConvertible
+  {}
+
+  friend constexpr bool
+  operator==(const NotSimpleViewConstIterEnd<CopyConvertible, MoveConvertible>&, const NotSimpleViewIterEnd&) {
+    return true;
+  }
+  friend constexpr bool
+  operator==(const NotSimpleViewConstIterEnd<CopyConvertible, MoveConvertible>&, const NotSimpleViewIterBegin&) {
+    return true;
+  }
+};
+
+/*
+ * Goal: We will need a way to get a stride_view<true>::__iterator and a
+ * stride_view<false>::__iterator because those are the two possible types
+ * of the stride_view::__iterator constructor. The template value is determined
+ * by whether the stride_view::__iterator is derivative of a stride_view over a
+ * view that is simple.
+ *
+ * So, first things first, we need to build a stride_view over a (non-)simple view.
+ * There are (at least) two ways that a view can be non-simple:
+ * 1. The iterator type for const begin is different than the iterator type for begin
+ * 2. The iterator type for const end is different that the iterator type for end
+ *
+ * So, let's create two different classes where that is the case so that we can test
+ * for those conditions individually. We parameterize with a template to decide
+ * whether to
+ * 1. enable converting constructors between the non-const and the const version.
+ * That feature is important for testing the stride_view::__iterator<true> converting
+ * constructor from a stride_view::_iterator<false> iterator.
+ * 2. enable copyability. That feature is important for testing whether the requirement
+ * the that copy constructor for the stride_view::__iterator<false> type actually moves
+ * the underlying iterator.
+ */
+template <bool CopyConvertible = false, bool MoveConvertible = true>
+struct NotSimpleViewDifferentBegin : std::ranges::view_base {
+  constexpr NotSimpleViewConstIterBegin<CopyConvertible, MoveConvertible> begin() const { return {}; }
+  constexpr NotSimpleViewIterBegin begin() { return {}; }
+
+  constexpr NotSimpleViewIterEnd end() const { return {}; }
+};
+
+template <bool CopyConvertible = false, bool MoveConvertible = true>
+struct NotSimpleViewDifferentEnd : std::ranges::view_base {
+  constexpr NotSimpleViewIterBegin begin() const { return {}; }
+  constexpr NotSimpleViewConstIterEnd<CopyConvertible, MoveConvertible> end() const { return {}; }
+  constexpr NotSimpleViewIterEnd end() { return {}; }
+};
+
+constexpr bool non_simple_view_iter_ctor_test() {
+  using NotSimpleStrideView          = std::ranges::stride_view<NotSimpleViewDifferentBegin<false>>;
+  using NotSimpleStrideViewIter      = std::ranges::iterator_t<NotSimpleStrideView>;
+  using NotSimpleStrideViewIterConst = std::ranges::iterator_t<const NotSimpleStrideView>;
+  static_assert(!std::is_same_v<NotSimpleStrideViewIterConst, NotSimpleStrideViewIter>);
+  return true;
+}
+
+constexpr bool non_const_iterator_copy_ctor() {
+  // All tests share the following general configuration.
+  //
+  // Instantiate a stride view StrideView over a non-simple view (NotSimpleViewBeingStrided) whose
+  // 1. std::ranges::iterator_t<StrideView> base's type is NotSimpleViewBeingStridedIterator
+  // 2. std::ranges::iterator_t<const StrideView> base's type is NotSimpleViewBeingStridedConstIterator
+  // 3. NotSimpleViewBeingStridedIterator is ONLY move-convertible to NotSimpleViewBeingStridedConstIterator
+  // 4. std::ranges::sentinel_t are the same whether SV is const or not.
+  // 5. the type of StrideView::end is the same whether StrideView is const or not.
+  // 6. the type of StrideView::begin is stride_view::iterator<true> when StrideView is const and
+  //    stride_view::iterator<false> when StrideView is non const.
+  // Visually, it looks like this:
+  //
+  //  NotSimpleViewBeingStrided(Const)Iterator <-----
+  //                ^                               |
+  //                |                               |
+  //                | begin (const?)                |
+  //                |                               |
+  //     NotSimpleViewBeingStrided                  |
+  //                ^                               |
+  //                |                               |
+  //                | Strides over                  |
+  //                |                               |
+  //            StrideView                          |
+  //                |                               |
+  //                | begin (const?)                |
+  //                |                               |
+  //                \/                              |
+  //       StrideView(Const)Iter                    |
+  //                |                               |
+  //                | base                          |
+  //                |                               |
+  //                ---------------------------------
+
+  {
+    // Stride over non-simple view over whose iterators are copy convertible -- should look (statically)
+    // like it is possible copy construct the stride view's iterator (the move-only requirement comes from
+    // a move of the current between the copied-from iterator to the copied-to iterator).
+    using NotSimpleViewBeingStrided = NotSimpleViewDifferentEnd<true, false>;
+    //using NotSimpleViewBeingStridedIterator      = std::ranges::iterator_t<NotSimpleViewBeingStrided>;
+    //using NotSimpleViewBeingStridedConstIterator = std::ranges::iterator_t<const NotSimpleViewBeingStrided>;
+
+    using StrideView = std::ranges::stride_view<NotSimpleViewBeingStrided>;
+
+    using StrideViewIter      = std::ranges::iterator_t<StrideView>;
+    using StrideViewConstIter = std::ranges::iterator_t<const StrideView>;
+
+    //using StrideViewSentinel      = std::ranges::sentinel_t<StrideView>;
+    //using StrideViewConstSentinel = std::ranges::sentinel_t<const StrideView>;
+
+    static_assert(std::convertible_to<StrideViewIter, StrideViewConstIter>);
+    static_assert(std::constructible_from<StrideViewConstIter, StrideViewIter>);
+  }
+
+  {
+    // Stride over non-simple view over whose iterators are move convertible -- should look (statically)
+    // like it is possible copy construct the stride view's iterator (the move-only requirement comes from
+    // a move of the current between the copied-from iterator to the copied-to iterator).
+    using NotSimpleViewBeingStrided = NotSimpleViewDifferentEnd<false, true>;
+    //using NotSimpleViewBeingStridedIterator      = std::ranges::iterator_t<NotSimpleViewBeingStrided>;
+    //using NotSimpleViewBeingStridedConstIterator = std::ranges::iterator_t<const NotSimpleViewBeingStrided>;
+
+    using StrideView = std::ranges::stride_view<NotSimpleViewBeingStrided>;
+
+    using StrideViewIter      = std::ranges::iterator_t<StrideView>;
+    using StrideViewConstIter = std::ranges::iterator_t<const StrideView>;
+
+    //using StrideViewSentinel      = std::ranges::sentinel_t<StrideView>;
+    //using StrideViewConstSentinel = std::ranges::sentinel_t<const StrideView>;
+
+    static_assert(std::convertible_to<StrideViewIter, StrideViewConstIter>);
+    static_assert(std::constructible_from<StrideViewConstIter, StrideViewIter>);
+  }
+
+  {
+    // Stride over non-simple view over whose iterators are not convertible -- should not be able
+    // to copy construct the stride view's iterator.
+    using NotSimpleViewBeingStrided = NotSimpleViewDifferentEnd<false, false>;
+    //using NotSimpleViewBeingStridedIterator      = std::ranges::iterator_t<NotSimpleViewBeingStrided>;
+    //using NotSimpleViewBeingStridedConstIterator = std::ranges::iterator_t<const NotSimpleViewBeingStrided>;
+
+    using StrideView = std::ranges::stride_view<NotSimpleViewBeingStrided>;
+
+    using StrideViewIter      = std::ranges::iterator_t<StrideView>;
+    using StrideViewConstIter = std::ranges::iterator_t<const StrideView>;
+
+    //using StrideViewSentinel      = std::ranges::sentinel_t<StrideView>;
+    //using StrideViewConstSentinel = std::ranges::sentinel_t<const StrideView>;
+
+    static_assert(!std::convertible_to<StrideViewIter, StrideViewConstIter>);
+    static_assert(!std::constructible_from<StrideViewConstIter, StrideViewIter>);
+  }
+
+  {
+    // Stride over non-simple view over whose iterators are not convertible -- should not be able
+    // to copy construct the stride view's iterator.
+    using NotSimpleViewBeingStrided         = NotSimpleViewDifferentEnd<false, true>;
+    using NotSimpleViewBeingStridedIterator = std::ranges::iterator_t<NotSimpleViewBeingStrided>;
+    //using NotSimpleViewBeingStridedConstIterator = std::ranges::iterator_t<const NotSimpleViewBeingStrided>;
+
+    using StrideView = std::ranges::stride_view<NotSimpleViewBeingStrided>;
+
+    using StrideViewIter      = std::ranges::iterator_t<StrideView>;
+    using StrideViewConstIter = std::ranges::iterator_t<const StrideView>;
+
+    //using StrideViewSentinel      = std::ranges::sentinel_t<StrideView>;
+    //using StrideViewConstSentinel = std::ranges::sentinel_t<const StrideView>;
+
+    static_assert(std::convertible_to<NotSimpleViewBeingStridedIterator, NotSimpleViewBeingStridedIterator>);
+    static_assert(std::convertible_to<StrideViewIter, StrideViewConstIter>);
+
+    StrideView str{NotSimpleViewBeingStrided{}, 5};
+    // Confirm (5)
+    ASSERT_SAME_TYPE(StrideViewIter, decltype(str.begin()));
+
+    // Now, do what we wanted the whole time: make sure that we can copy construct a
+    // stride_view::iterator<true> from a stride_view::iterator<false>. The copy
+    // constructor requires that the new __current_ StrideViewConstIter (type
+    // NotSimpleViewBeingStridedConstIterator) be constructable
+    // from the moved str.begin() __current_ (type NotSimpleViewBeingStridedConstIterator).
+    StrideViewConstIter iterator_copy{str.begin()};
+  }
+
+  {
+    // Stride over non-simple view over whose iterators are copy convertible -- should look (statically)
+    // like it is possible copy construct the stride view's iterator (the move-only requirement comes from
+    // a move of the current between the copied-from iterator to the copied-to iterator).
+    using NotSimpleViewBeingStrided = NotSimpleViewDifferentBegin<true, false>;
+    //using NotSimpleViewBeingStridedIterator      = std::ranges::iterator_t<NotSimpleViewBeingStrided>;
+    //using NotSimpleViewBeingStridedConstIterator = std::ranges::iterator_t<const NotSimpleViewBeingStrided>;
+
+    using StrideView = std::ranges::stride_view<NotSimpleViewBeingStrided>;
+
+    using StrideViewIter      = std::ranges::iterator_t<StrideView>;
+    using StrideViewConstIter = std::ranges::iterator_t<const StrideView>;
+
+    //using StrideViewSentinel      = std::ranges::sentinel_t<StrideView>;
+    //using StrideViewConstSentinel = std::ranges::sentinel_t<const StrideView>;
+
+    static_assert(std::convertible_to<StrideViewIter, StrideViewConstIter>);
+    static_assert(std::constructible_from<StrideViewConstIter, StrideViewIter>);
+  }
+
+  {
+    // Stride over non-simple view over whose iterators are move convertible -- should look (statically)
+    // like it is possible copy construct the stride view's iterator (the move-only requirement comes from
+    // a move of the current between the copied-from iterator to the copied-to iterator).
+    using NotSimpleViewBeingStrided = NotSimpleViewDifferentBegin<false, true>;
+    //using NotSimpleViewBeingStridedIterator      = std::ranges::iterator_t<NotSimpleViewBeingStrided>;
+    //using NotSimpleViewBeingStridedConstIterator = std::ranges::iterator_t<const NotSimpleViewBeingStrided>;
+
+    using StrideView = std::ranges::stride_view<NotSimpleViewBeingStrided>;
+
+    using StrideViewIter      = std::ranges::iterator_t<StrideView>;
+    using StrideViewConstIter = std::ranges::iterator_t<const StrideView>;
+
+    //using StrideViewSentinel      = std::ranges::sentinel_t<StrideView>;
+    //using StrideViewConstSentinel = std::ranges::sentinel_t<const StrideView>;
+
+    static_assert(std::convertible_to<StrideViewIter, StrideViewConstIter>);
+    static_assert(std::constructible_from<StrideViewConstIter, StrideViewIter>);
+  }
+
+  {
+    // Stride over non-simple view over whose iterators are not convertible -- should not be able
+    // to copy construct the stride view's iterator.
+    using NotSimpleViewBeingStrided = NotSimpleViewDifferentBegin<false, false>;
+    //using NotSimpleViewBeingStridedIterator      = std::ranges::iterator_t<NotSimpleViewBeingStrided>;
+    //using NotSimpleViewBeingStridedConstIterator = std::ranges::iterator_t<const NotSimpleViewBeingStrided>;
+
+    using StrideView = std::ranges::stride_view<NotSimpleViewBeingStrided>;
+
+    using StrideViewIter      = std::ranges::iterator_t<StrideView>;
+    using StrideViewConstIter = std::ranges::iterator_t<const StrideView>;
+
+    //using StrideViewSentinel      = std::ranges::sentinel_t<StrideView>;
+    //using StrideViewConstSentinel = std::ranges::sentinel_t<const StrideView>;
+
+    static_assert(!std::convertible_to<StrideViewIter, StrideViewConstIter>);
+    static_assert(!std::constructible_from<StrideViewConstIter, StrideViewIter>);
+  }
+
+  {
+    // The NotSimpleViewBeingStrided template parameters mean that NotSimpleViewBeingStridedIterator
+    // can be move-converted to NotSimpleViewBeingStridedConstIterator but not copy-converted.
+    using NotSimpleViewBeingStrided              = NotSimpleViewDifferentBegin<false, true>;
+    using NotSimpleViewBeingStridedIterator      = std::ranges::iterator_t<NotSimpleViewBeingStrided>;
+    using NotSimpleViewBeingStridedConstIterator = std::ranges::iterator_t<const NotSimpleViewBeingStrided>;
+
+    using StrideView = std::ranges::stride_view<NotSimpleViewBeingStrided>;
+
+    using StrideViewIter      = std::ranges::iterator_t<StrideView>;
+    using StrideViewConstIter = std::ranges::iterator_t<const StrideView>;
+
+    using StrideViewSentinel      = std::ranges::sentinel_t<StrideView>;
+    using StrideViewConstSentinel = std::ranges::sentinel_t<const StrideView>;
+
+    // Confirm (1) and (2)
+    ASSERT_SAME_TYPE(NotSimpleViewBeingStridedIterator, decltype(std::declval<StrideViewIter>().base()));
+    ASSERT_SAME_TYPE(NotSimpleViewBeingStridedConstIterator, decltype(std::declval<StrideViewConstIter>().base()));
+    // Confirm (3)
+    static_assert(std::convertible_to<NotSimpleViewBeingStridedIterator, NotSimpleViewBeingStridedIterator>);
+    static_assert(std::convertible_to<StrideViewIter, StrideViewConstIter>);
+    // Confirm (4)
+    ASSERT_SAME_TYPE(StrideViewSentinel, StrideViewConstSentinel);
+
+    StrideView str{NotSimpleViewBeingStrided{}, 5};
+    // Confirm (5)
+    ASSERT_SAME_TYPE(StrideViewIter, decltype(str.begin()));
+
+    // Now, do what we wanted the whole time: make sure that we can copy construct a
+    // stride_view::iterator<true> from a stride_view::iterator<false>. The copy
+    // constructor requires that the new __current_ StrideViewConstIter (type
+    // NotSimpleViewBeingStridedConstIterator) be constructable
+    // from the moved str.begin() __current_ (type NotSimpleViewBeingStridedConstIterator).
+    StrideViewConstIter iterator_copy{str.begin()};
+  }
+  return true;
+}
+
+int main(int, char**) {
+  non_simple_view_iter_ctor_test();
+  static_assert(non_simple_view_iter_ctor_test());
+
+  return 0;
+}
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/ctor.default.verify.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/ctor.default.verify.cpp
new file mode 100644
index 0000000000000..4fbe9c0d2498e
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/ctor.default.verify.cpp
@@ -0,0 +1,39 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+// expected-no-diagnostics
+
+// __iterator() requires default_initializable<iterator_t<_Base>> = default;
+
+#include <ranges>
+
+#include "../types.h"
+#include "test_iterators.h"
+
+struct NonDefaultConstructibleIterator : InputIterBase<NonDefaultConstructibleIterator> {
+  NonDefaultConstructibleIterator() = delete;
+  constexpr NonDefaultConstructibleIterator(int) {}
+};
+
+struct ViewWithNonDefaultConstructibleIterator : std::ranges::view_base {
+  constexpr NonDefaultConstructibleIterator begin() const { return NonDefaultConstructibleIterator{5}; }
+  constexpr std::default_sentinel_t end() const { return {}; }
+};
+template <>
+inline constexpr bool std::ranges::enable_borrowed_range<ViewWithNonDefaultConstructibleIterator> = true;
+
+// If the type of the iterator of the range being strided is non-default
+// constructible, then the stride view's iterator should not be default
+// constructible, either!
+static_assert(!std::is_default_constructible< std::ranges::iterator_t<ViewWithNonDefaultConstructibleIterator>>());
+// If the type of the iterator of the range being strided is default
+// constructible, then the stride view's iterator should be default
+// constructible, too!
+static_assert(std::is_default_constructible<
+              std::ranges::iterator_t< std::ranges::stride_view<std::ranges::ref_view<const int[3]>>>>());
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/equal.pass.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/equal.pass.cpp
new file mode 100644
index 0000000000000..29156e0fe0db6
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/equal.pass.cpp
@@ -0,0 +1,97 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+// friend constexpr bool operator==(__iterator const& __x, default_sentinel_t)
+// friend constexpr bool operator==(__iterator const& __x, __iterator const& __y)
+
+#include <cassert>
+#include <ranges>
+
+#include "test_iterators.h"
+#include "../types.h"
+
+template <class Iter>
+constexpr void testOne() {
+  using Range = BasicTestView<Iter, Iter>;
+  static_assert(std::ranges::common_range<Range>);
+  using StrideView = std::ranges::stride_view<Range>;
+
+  {
+    // simple test
+    {
+      int buffer[] = {0, 1, 2, -1, 4, 5, 6, 7};
+      const Range input(Iter{buffer}, Iter{buffer + 8});
+      const StrideView sv(input, 1);
+      const StrideView sv_too(input, 2);
+      auto b     = sv.begin();
+      auto e     = sv.end();
+      auto b_too = sv_too.begin();
+
+      assert(b == b);
+      assert(!(b != b));
+
+      // When Range is a bidirectional_range, the type of e is
+      // default_sentinel_t and those do not compare to one another.
+      if constexpr (!std::ranges::bidirectional_range<Range>) {
+        assert(e == e);
+        assert(!(e != e));
+      }
+      assert(!(b == e));
+      assert(b != e);
+
+      std::advance(b, 8);
+      std::advance(b_too, 4);
+
+      assert(b == b_too);
+      assert(!(b != b_too));
+
+      assert(b == b);
+      assert(!(b != b));
+
+      // See above.
+      if constexpr (!std::ranges::bidirectional_range<Range>) {
+        assert(e == e);
+        assert(!(e != e));
+      }
+
+      assert(b == e);
+      assert(!(b != e));
+    }
+
+    // Default-constructed iterators compare equal.
+    {
+      int buffer[] = {0, 1, 2, -1, 4, 5, 6};
+      const Range input(Iter{buffer}, Iter{buffer + 7});
+      const std::ranges::stride_view sv(input, 1);
+      using StrideViewIter = decltype(sv.begin());
+      StrideViewIter i1;
+      StrideViewIter i2;
+      assert(i1 == i2);
+      assert(!(i1 != i2));
+    }
+  }
+}
+
+constexpr bool test() {
+  testOne<forward_iterator<int*>>();
+  testOne<bidirectional_iterator<int*>>();
+  testOne<random_access_iterator<int*>>();
+  testOne<contiguous_iterator<int*>>();
+  testOne<int*>();
+
+  return true;
+}
+
+int main(int, char**) {
+  test();
+  static_assert(test());
+
+  return 0;
+}
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/iter_move.pass.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/iter_move.pass.cpp
new file mode 100644
index 0000000000000..25ccf30abe0c5
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/iter_move.pass.cpp
@@ -0,0 +1,98 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+//  friend constexpr range_rvalue_reference_t<_Base> iter_move(__iterator const& __it)
+//         noexcept(noexcept(ranges::iter_move(__it.__current_)))
+
+#include <ranges>
+#include <vector>
+
+#include "../types.h"
+#include "__ranges/access.h"
+#include "test_macros.h"
+
+template <typename T>
+concept iter_moveable = requires(T&& t) { std::ranges::iter_move(t); };
+
+constexpr bool test() {
+  {
+    int a[] = {4, 3, 2, 1};
+
+    int iter_move_counter(0);
+    using View       = IterMoveIterSwapTestRange<int*, true, true>;
+    using StrideView = std::ranges::stride_view<View>;
+    auto svb         = StrideView(View(a, a + 4, &iter_move_counter), 1).begin();
+
+    static_assert(iter_moveable<std::ranges::iterator_t<StrideView>>);
+    ASSERT_SAME_TYPE(int, decltype(std::ranges::iter_move(svb)));
+    static_assert(noexcept(std::ranges::iter_move(svb)));
+
+    auto&& result = std::ranges::iter_move(svb);
+    assert(iter_move_counter == 1);
+    assert(result == 4);
+
+    svb++;
+    result = std::ranges::iter_move(svb);
+    assert(iter_move_counter == 2);
+    assert(result == 3);
+  }
+
+  {
+    int a[] = {1, 2, 3, 4};
+
+    int iter_move_counter(0);
+    using View       = IterMoveIterSwapTestRange<int*, true, false>;
+    using StrideView = std::ranges::stride_view<View>;
+    auto svb         = StrideView(View(a, a + 4, &iter_move_counter), 1).begin();
+
+    static_assert(iter_moveable<std::ranges::iterator_t<StrideView>>);
+    ASSERT_SAME_TYPE(int, decltype(std::ranges::iter_move(svb)));
+    static_assert(!noexcept(std::ranges::iter_move(svb)));
+
+    auto&& result = std::ranges::iter_move(svb);
+    assert(iter_move_counter == 1);
+    assert(result == 1);
+
+    svb++;
+    result = std::ranges::iter_move(svb);
+    assert(iter_move_counter == 2);
+    assert(result == 2);
+  }
+
+  {
+    std::vector<int> a = {4, 5, 6, 7, 8};
+
+    int iter_move_counter(0);
+    using View = IterMoveIterSwapTestRange<std::vector<int>::iterator, true, false>;
+
+    using StrideView = std::ranges::stride_view<View>;
+    auto svb         = StrideView(View(a.begin(), a.end(), &iter_move_counter), 1).begin();
+
+    static_assert(!noexcept(std::ranges::iter_move(svb)));
+
+    auto&& result = std::ranges::iter_move(svb);
+    assert(iter_move_counter == 1);
+    assert(result == 4);
+
+    svb++;
+    result = std::ranges::iter_move(svb);
+    assert(iter_move_counter == 2);
+    assert(result == 5);
+  }
+
+  return true;
+}
+
+int main(int, char**) {
+  test();
+  static_assert(test());
+
+  return 0;
+}
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/iter_swap.pass.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/iter_swap.pass.cpp
new file mode 100644
index 0000000000000..c9b87dfec6ecd
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/iter_swap.pass.cpp
@@ -0,0 +1,88 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+//  friend constexpr void iter_swap(__iterator const& __x, __iterator const& __y)
+//  noexcept(noexcept(ranges::iter_swap(__x.__current_, __y.__current_)))
+//  requires indirectly_swappable<iterator_t<_Base>>
+
+#include <ranges>
+
+#include "../types.h"
+
+template <typename T>
+concept swappable = requires(T&& t, T&& u) { std::ranges::iter_swap(t, u); };
+
+constexpr bool test() {
+  {
+    int a[] = {1, 2, 3, 4};
+    int b[] = {5, 6, 7, 8};
+
+    int iter_move_counter_one(0);
+    int iter_move_counter_two(0);
+    using View       = IterMoveIterSwapTestRange<int*, true, true>;
+    using StrideView = std::ranges::stride_view<View>;
+    auto svba        = StrideView(View(a, a + 4, &iter_move_counter_one), 1).begin();
+    auto svbb        = StrideView(View(b, b + 4, &iter_move_counter_two), 1).begin();
+
+    static_assert(swappable<std::ranges::iterator_t<StrideView>>);
+    static_assert(noexcept(std::ranges::iter_swap(svba, svbb)));
+
+    assert(a[0] == 1);
+    assert(b[0] == 5);
+
+    std::ranges::iter_swap(svba, svbb);
+    assert(iter_move_counter_one == 1);
+    assert(iter_move_counter_two == 1);
+
+    assert(a[0] == 5);
+    assert(b[0] == 1);
+  }
+
+  {
+    int a[] = {1, 2, 3, 4};
+    int b[] = {5, 6, 7, 8};
+
+    int iter_move_counter_one(0);
+    int iter_move_counter_two(0);
+    using View       = IterMoveIterSwapTestRange<int*, true, false>;
+    using StrideView = std::ranges::stride_view<View>;
+    auto svba        = StrideView(View(a, a + 4, &iter_move_counter_one), 1).begin();
+    auto svbb        = StrideView(View(b, b + 4, &iter_move_counter_two), 1).begin();
+
+    static_assert(swappable<std::ranges::iterator_t<StrideView>>);
+    static_assert(!noexcept(std::ranges::iter_swap(svba, svbb)));
+
+    assert(a[0] == 1);
+    assert(b[0] == 5);
+
+    std::ranges::iter_swap(svba, svbb);
+
+    assert(iter_move_counter_one == 1);
+    assert(iter_move_counter_two == 1);
+    assert(a[0] == 5);
+    assert(b[0] == 1);
+  }
+
+  {
+    using View       = IterMoveIterSwapTestRange<int*, false, false>;
+    using StrideView = std::ranges::stride_view<View>;
+
+    static_assert(!swappable<std::ranges::iterator_t<StrideView>>);
+  }
+
+  return true;
+}
+
+int main(int, char**) {
+  test();
+  static_assert(test());
+
+  return 0;
+}
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/operator.pass.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/operator.pass.cpp
new file mode 100644
index 0000000000000..dd8b9e9127e76
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/iterator/operator.pass.cpp
@@ -0,0 +1,423 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+// constexpr __iterator& operator++()
+// constexpr void operator++(int)
+// constexpr __iterator operator++(int)
+// constexpr __iterator& operator--()
+// constexpr __iterator operator--(int)
+// constexpr __iterator& operator+=(difference_type __n)
+// constexpr __iterator& operator-=(difference_type __n)
+// friend constexpr bool operator==(__iterator const& __x, default_sentinel_t)
+// friend constexpr bool operator==(__iterator const& __x, __iterator const& __y)
+// friend constexpr bool operator<(__iterator const& __x, __iterator const& __y)
+// friend constexpr bool operator>(__iterator const& __x, __iterator const& __y)
+// friend constexpr bool operator<=(__iterator const& __x, __iterator const& __y)
+// friend constexpr bool operator>=(__iterator const& __x, __iterator const& __y)
+// friend constexpr bool operator<=>(__iterator const& __x, __iterator const& __y)
+
+#include <functional>
+#include <iterator>
+#include <ranges>
+#include <type_traits>
+#include <utility>
+#include <vector>
+
+#include "../types.h"
+#include "__compare/three_way_comparable.h"
+#include "__concepts/equality_comparable.h"
+#include "__iterator/concepts.h"
+#include "__iterator/default_sentinel.h"
+#include "__iterator/distance.h"
+#include "__ranges/access.h"
+#include "__ranges/concepts.h"
+#include "__ranges/stride_view.h"
+#include "test_iterators.h"
+
+template <class T>
+concept CanPlusEqual = std::is_same_v<T&, decltype(std::declval<T>() += 1)> && requires(T& t) { t += 1; };
+template <class T>
+concept CanMinusEqual = std::is_same_v<T&, decltype(std::declval<T>() -= 1)> && requires(T& t) { t -= 1; };
+
+template <class T>
+concept CanMinus =
+    // Note: Do *not* use std::iterator_traits here because T may not have
+    // all the required pieces when it is not a forward_range.
+    std::is_same_v<typename T::difference_type, decltype(std::declval<T>() - std::declval<T>())> &&
+    requires(T& t) { t - t; };
+
+template <class T>
+concept CanSentinelMinus =
+    // Note: Do *not* use std::iterator_traits here because T may not have
+    // all the required pieces when it is not a forward_range.
+    std::is_same_v<typename T::difference_type, decltype(std::declval<T>() - std::default_sentinel)> &&
+    std::is_same_v<typename T::difference_type, decltype(std::default_sentinel - std::declval<T>())> && requires(T& t) {
+      t - std::default_sentinel;
+      std::default_sentinel - t;
+    };
+
+template <class T>
+concept CanDifferencePlus = std::is_same_v<T, decltype(std::declval<T>() + 1)> && requires(T& t) { t + 1; };
+template <class T>
+concept CanDifferenceMinus = std::is_same_v<T, decltype(std::declval<T>() - 1)> && requires(T& t) { t - 1; };
+
+template <class T>
+concept CanPostDecrement = std::is_same_v<T, decltype(std::declval<T>()--)> && requires(T& t) { t--; };
+template <class T>
+concept CanPreDecrement = std::is_same_v<T&, decltype(--std::declval<T>())> && requires(T& t) { --t; };
+
+template <class T>
+concept CanSubscript = requires(T& t) { t[5]; };
+
+// What operators are valid for an iterator derived from a stride view
+// over an input view.(sized sentinel)
+using InputView = BasicTestView<cpp17_input_iterator<int*>, sized_sentinel<cpp17_input_iterator<int*>>>;
+using StrideViewOverInputViewIterator = std::ranges::iterator_t<std::ranges::stride_view<InputView>>;
+
+static_assert(std::weakly_incrementable<StrideViewOverInputViewIterator>);
+
+static_assert(!CanPostDecrement<StrideViewOverInputViewIterator>);
+static_assert(!CanPreDecrement<StrideViewOverInputViewIterator>);
+static_assert(!CanPlusEqual<StrideViewOverInputViewIterator>);
+static_assert(!CanMinusEqual<StrideViewOverInputViewIterator>);
+static_assert(!CanMinus<StrideViewOverInputViewIterator>);
+static_assert(!CanDifferencePlus<StrideViewOverInputViewIterator>);
+static_assert(!CanDifferenceMinus<StrideViewOverInputViewIterator>);
+static_assert(CanSentinelMinus<StrideViewOverInputViewIterator>);
+static_assert(std::invocable<std::equal_to<>, StrideViewOverInputViewIterator, StrideViewOverInputViewIterator>);
+static_assert(std::invocable<std::equal_to<>, StrideViewOverInputViewIterator, std::default_sentinel_t>);
+static_assert(std::invocable<std::equal_to<>, std::default_sentinel_t, StrideViewOverInputViewIterator>);
+
+static_assert(!std::is_invocable_v<std::less<>, StrideViewOverInputViewIterator, StrideViewOverInputViewIterator>);
+static_assert(
+    !std::is_invocable_v<std::less_equal<>, StrideViewOverInputViewIterator, StrideViewOverInputViewIterator>);
+static_assert(!std::is_invocable_v<std::greater<>, StrideViewOverInputViewIterator, StrideViewOverInputViewIterator>);
+static_assert(
+    !std::is_invocable_v<std::greater_equal<>, StrideViewOverInputViewIterator, StrideViewOverInputViewIterator>);
+
+static_assert(!CanSubscript<StrideViewOverInputViewIterator>);
+
+// What operators are valid for an iterator derived from a stride view
+// over a forward view.(sized sentinel)
+using ForwardView                       = BasicTestView<forward_iterator<int*>, sized_sentinel<forward_iterator<int*>>>;
+using StrideViewOverForwardViewIterator = std::ranges::iterator_t<std::ranges::stride_view<ForwardView>>;
+
+static_assert(std::weakly_incrementable<StrideViewOverForwardViewIterator>);
+
+static_assert(!CanPostDecrement<StrideViewOverForwardViewIterator>);
+static_assert(!CanPreDecrement<StrideViewOverForwardViewIterator>);
+static_assert(!CanPlusEqual<StrideViewOverForwardViewIterator>);
+static_assert(!CanMinusEqual<StrideViewOverForwardViewIterator>);
+static_assert(!CanMinus<StrideViewOverForwardViewIterator>);
+static_assert(!CanDifferencePlus<StrideViewOverForwardViewIterator>);
+static_assert(!CanDifferenceMinus<StrideViewOverForwardViewIterator>);
+static_assert(CanSentinelMinus<StrideViewOverForwardViewIterator>);
+static_assert(std::invocable<std::equal_to<>, StrideViewOverForwardViewIterator, StrideViewOverForwardViewIterator>);
+static_assert(std::invocable<std::equal_to<>, StrideViewOverForwardViewIterator, std::default_sentinel_t>);
+static_assert(std::invocable<std::equal_to<>, std::default_sentinel_t, StrideViewOverForwardViewIterator>);
+
+static_assert(!std::is_invocable_v<std::less<>, StrideViewOverForwardViewIterator, StrideViewOverForwardViewIterator>);
+static_assert(
+    !std::is_invocable_v<std::less_equal<>, StrideViewOverForwardViewIterator, StrideViewOverForwardViewIterator>);
+static_assert(
+    !std::is_invocable_v<std::greater<>, StrideViewOverForwardViewIterator, StrideViewOverForwardViewIterator>);
+static_assert(
+    !std::is_invocable_v<std::greater_equal<>, StrideViewOverForwardViewIterator, StrideViewOverForwardViewIterator>);
+
+static_assert(!CanSubscript<StrideViewOverForwardViewIterator>);
+
+// What operators are valid for an iterator derived from a stride view
+// over a bidirectional view. (sized sentinel)
+using BidirectionalView = BasicTestView<bidirectional_iterator<int*>, sized_sentinel<bidirectional_iterator<int*>>>;
+using StrideViewOverBidirectionalViewIterator = std::ranges::iterator_t<std::ranges::stride_view<BidirectionalView>>;
+
+static_assert(CanPostDecrement<StrideViewOverBidirectionalViewIterator>);
+static_assert(CanPreDecrement<StrideViewOverBidirectionalViewIterator>);
+static_assert(!CanPlusEqual<StrideViewOverBidirectionalViewIterator>);
+static_assert(!CanMinusEqual<StrideViewOverBidirectionalViewIterator>);
+static_assert(!CanMinus<StrideViewOverBidirectionalViewIterator>);
+static_assert(!CanDifferencePlus<StrideViewOverBidirectionalViewIterator>);
+static_assert(!CanDifferenceMinus<StrideViewOverBidirectionalViewIterator>);
+static_assert(CanSentinelMinus<StrideViewOverBidirectionalViewIterator>);
+static_assert(
+    std::invocable<std::equal_to<>, StrideViewOverBidirectionalViewIterator, StrideViewOverBidirectionalViewIterator>);
+static_assert(std::invocable<std::equal_to<>, StrideViewOverBidirectionalViewIterator, std::default_sentinel_t>);
+static_assert(std::invocable<std::equal_to<>, std::default_sentinel_t, StrideViewOverBidirectionalViewIterator>);
+
+static_assert(!std::is_invocable_v<std::less<>,
+                                   StrideViewOverBidirectionalViewIterator,
+                                   StrideViewOverBidirectionalViewIterator>);
+static_assert(!std::is_invocable_v<std::less_equal<>,
+                                   StrideViewOverBidirectionalViewIterator,
+                                   StrideViewOverBidirectionalViewIterator>);
+static_assert(!std::is_invocable_v<std::greater<>,
+                                   StrideViewOverBidirectionalViewIterator,
+                                   StrideViewOverBidirectionalViewIterator>);
+static_assert(!std::is_invocable_v<std::greater_equal<>,
+                                   StrideViewOverBidirectionalViewIterator,
+                                   StrideViewOverBidirectionalViewIterator>);
+
+static_assert(!CanSubscript<StrideViewOverBidirectionalViewIterator>);
+
+// What operators are valid for an iterator derived from a stride view
+// over a random access view. (non sized sentinel)
+using RandomAccessView                       = BasicTestView<random_access_iterator<int*>>;
+using StrideViewOverRandomAccessViewIterator = std::ranges::iterator_t<std::ranges::stride_view<RandomAccessView>>;
+
+static_assert(std::weakly_incrementable<StrideViewOverRandomAccessViewIterator>);
+
+static_assert(CanPostDecrement<StrideViewOverRandomAccessViewIterator>);
+static_assert(CanPreDecrement<StrideViewOverRandomAccessViewIterator>);
+static_assert(CanPlusEqual<StrideViewOverRandomAccessViewIterator>);
+static_assert(CanMinusEqual<StrideViewOverRandomAccessViewIterator>);
+static_assert(CanMinus<StrideViewOverRandomAccessViewIterator>);
+static_assert(CanDifferencePlus<StrideViewOverRandomAccessViewIterator>);
+static_assert(CanDifferenceMinus<StrideViewOverRandomAccessViewIterator>);
+static_assert(!CanSentinelMinus<StrideViewOverRandomAccessViewIterator>);
+static_assert(
+    std::invocable<std::equal_to<>, StrideViewOverRandomAccessViewIterator, StrideViewOverRandomAccessViewIterator>);
+static_assert(std::invocable<std::equal_to<>, StrideViewOverRandomAccessViewIterator, std::default_sentinel_t>);
+static_assert(std::invocable<std::equal_to<>, std::default_sentinel_t, StrideViewOverRandomAccessViewIterator>);
+
+static_assert(
+    std::is_invocable_v<std::less<>, StrideViewOverRandomAccessViewIterator, StrideViewOverRandomAccessViewIterator>);
+static_assert(std::is_invocable_v<std::less_equal<>,
+                                  StrideViewOverRandomAccessViewIterator,
+                                  StrideViewOverRandomAccessViewIterator>);
+static_assert(std::is_invocable_v<std::greater<>,
+                                  StrideViewOverRandomAccessViewIterator,
+                                  StrideViewOverRandomAccessViewIterator>);
+static_assert(std::is_invocable_v<std::greater_equal<>,
+                                  StrideViewOverRandomAccessViewIterator,
+                                  StrideViewOverRandomAccessViewIterator>);
+
+static_assert(CanSubscript<StrideViewOverRandomAccessViewIterator>);
+
+using EqualableView               = BasicTestView<cpp17_input_iterator<int*>>;
+using EqualableViewStrideView     = std::ranges::stride_view<EqualableView>;
+using EqualableViewStrideViewIter = std::ranges::iterator_t<EqualableViewStrideView>;
+
+static_assert(std::equality_comparable<std::ranges::iterator_t<EqualableView>>);
+static_assert(std::equality_comparable<EqualableViewStrideViewIter>);
+
+static_assert(!std::three_way_comparable<std::ranges::iterator_t<EqualableView>>);
+static_assert(!std::ranges::random_access_range<EqualableView>);
+static_assert(!std::three_way_comparable<EqualableView>);
+
+using ThreeWayComparableView           = BasicTestView<three_way_contiguous_iterator<int*>>;
+using ThreeWayComparableViewStrideView = std::ranges::stride_view<ThreeWayComparableView>;
+using ThreeWayComparableStrideViewIter = std::ranges::iterator_t<ThreeWayComparableViewStrideView>;
+
+static_assert(std::three_way_comparable<std::ranges::iterator_t<ThreeWayComparableView>>);
+static_assert(std::ranges::random_access_range<ThreeWayComparableView>);
+static_assert(std::three_way_comparable<ThreeWayComparableStrideViewIter>);
+
+using UnEqualableView               = ViewOverNonCopyableIterator<cpp20_input_iterator<int*>>;
+using UnEqualableViewStrideView     = std::ranges::stride_view<UnEqualableView>;
+using UnEqualableViewStrideViewIter = std::ranges::iterator_t<UnEqualableViewStrideView>;
+
+static_assert(!std::equality_comparable<std::ranges::iterator_t<UnEqualableView>>);
+static_assert(!std::equality_comparable<UnEqualableViewStrideViewIter>);
+
+static_assert(!std::three_way_comparable<std::ranges::iterator_t<UnEqualableView>>);
+static_assert(!std::ranges::random_access_range<UnEqualableView>);
+static_assert(!std::three_way_comparable<UnEqualableView>);
+
+template <typename Iter>
+  requires std::sized_sentinel_for<Iter, Iter> && (!std::forward_iterator<Iter>)
+constexpr bool test_non_forward_operator_minus(Iter zero_begin, Iter one_begin, Iter end) {
+  using Base = BasicTestView<Iter, Iter>;
+  // Test the non-forward-range operator- between two iterators (i.e., ceil).
+  // First, what operators are valid for an iterator derived from a stride view
+  // over a sized input view.
+  using StrideViewIterator = std::ranges::iterator_t<std::ranges::stride_view<Base>>;
+
+  static_assert(std::weakly_incrementable<StrideViewIterator>);
+
+  static_assert(!CanPostDecrement<StrideViewIterator>);
+  static_assert(!CanPreDecrement<StrideViewIterator>);
+  static_assert(!CanPlusEqual<StrideViewIterator>);
+  static_assert(!CanMinusEqual<StrideViewIterator>);
+  static_assert(!CanDifferencePlus<StrideViewIterator>);
+  static_assert(!CanDifferenceMinus<StrideViewIterator>);
+  static_assert(CanSentinelMinus<StrideViewIterator>);
+
+  static_assert(!std::is_invocable_v<std::less<>, StrideViewIterator, StrideViewIterator>);
+  static_assert(!std::is_invocable_v<std::less_equal<>, StrideViewIterator, StrideViewIterator>);
+  static_assert(!std::is_invocable_v<std::greater<>, StrideViewIterator, StrideViewIterator>);
+  static_assert(!std::is_invocable_v<std::greater_equal<>, StrideViewIterator, StrideViewIterator>);
+  static_assert(std::is_invocable_v<std::equal_to<>, StrideViewIterator, StrideViewIterator>);
+  static_assert(std::is_invocable_v<std::equal_to<>, std::default_sentinel_t, StrideViewIterator>);
+  static_assert(std::is_invocable_v<std::equal_to<>, StrideViewIterator, std::default_sentinel_t>);
+  static_assert(!CanSubscript<StrideViewIterator>);
+
+  auto base_view_offset_zero             = Base(zero_begin, end);
+  auto base_view_offset_one              = Base(one_begin, end);
+  auto stride_view_over_base_zero_offset = std::ranges::stride_view(base_view_offset_zero, 3);
+  auto stride_view_over_base_one_offset  = std::ranges::stride_view(base_view_offset_one, 3);
+
+  auto sv_zero_offset_begin = stride_view_over_base_zero_offset.begin();
+  auto sv_one_offset_begin  = stride_view_over_base_one_offset.begin();
+
+  auto sv_zero_offset_zeroth_index = sv_zero_offset_begin;
+  auto sv_zero_offset_third_index  = ++sv_zero_offset_begin;
+  auto sv_zero_offset_sixth_index  = ++sv_zero_offset_begin;
+
+  auto sv_one_offset_oneth_index  = sv_one_offset_begin;
+  auto sv_one_offset_fourth_index = ++sv_one_offset_begin;
+
+  static_assert(std::sized_sentinel_for<std::ranges::iterator_t<Base>, std::ranges::iterator_t<Base>>);
+  static_assert(CanMinus<decltype(sv_zero_offset_begin)>);
+
+  // Check positive __n with exact multiple of left's stride.
+  assert(sv_zero_offset_third_index - sv_zero_offset_zeroth_index == 1);
+  assert(sv_zero_offset_sixth_index - sv_zero_offset_zeroth_index == 2);
+  // Check positive __n with non-exact multiple of left's stride (will do ceil here).
+  assert(sv_one_offset_oneth_index - sv_zero_offset_zeroth_index == 1);
+  assert(sv_one_offset_fourth_index - sv_zero_offset_zeroth_index == 2);
+
+  // Check negative __n with exact multiple of left's stride.
+  assert(sv_zero_offset_zeroth_index - sv_zero_offset_third_index == -1);
+  assert(sv_zero_offset_zeroth_index - sv_zero_offset_sixth_index == -2);
+  // Check negative __n with non-exact multiple of left's stride (will do ceil here).
+  assert(sv_zero_offset_zeroth_index - sv_one_offset_oneth_index == -1);
+  assert(sv_zero_offset_zeroth_index - sv_one_offset_fourth_index == -2);
+
+  assert(stride_view_over_base_zero_offset.end() == std::default_sentinel);
+  assert(std::default_sentinel == stride_view_over_base_zero_offset.end());
+
+  assert(stride_view_over_base_zero_offset.end() - std::default_sentinel == 0);
+  assert(std::default_sentinel - stride_view_over_base_zero_offset.begin() ==
+         std::ranges::distance(stride_view_over_base_zero_offset));
+  assert(stride_view_over_base_zero_offset.begin() - std::default_sentinel ==
+         -std::ranges::distance(stride_view_over_base_zero_offset));
+
+  return true;
+}
+
+template <std::forward_iterator Iter>
+constexpr bool test_forward_operator_minus(Iter begin, Iter end) {
+  // Test the forward-range operator- between two iterators (i.e., no ceil).
+  using Base = BasicTestView<Iter, Iter>;
+  //int arr[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+
+  // First, what operators are valid for an iterator derived from a stride view
+  // over a sized forward view (even though it is actually much more than that!).
+  using StrideViewIterator = std::ranges::iterator_t<std::ranges::stride_view<Base>>;
+
+  static_assert(std::weakly_incrementable<StrideViewIterator>);
+  static_assert(CanMinus<StrideViewIterator>);
+  static_assert(CanSentinelMinus<StrideViewIterator>);
+
+  auto base_view_offset_zero             = Base(begin, end);
+  auto base_view_offset_one              = Base(begin + 1, end);
+  auto stride_view_over_base_zero_offset = std::ranges::stride_view(base_view_offset_zero, 3);
+  auto stride_view_over_base_one_offset  = std::ranges::stride_view(base_view_offset_one, 3);
+
+  auto sv_zero_offset_begin = stride_view_over_base_zero_offset.begin();
+  auto sv_one_offset_begin  = stride_view_over_base_one_offset.begin();
+
+  auto sv_zero_offset_should_be_one   = sv_zero_offset_begin;
+  auto sv_zero_offset_should_be_four  = ++sv_zero_offset_begin;
+  auto sv_zero_offset_should_be_seven = ++sv_zero_offset_begin;
+
+  auto sv_one_offset_should_be_two  = sv_one_offset_begin;
+  auto sv_one_offset_should_be_five = ++sv_one_offset_begin;
+
+  static_assert(std::sized_sentinel_for<std::ranges::iterator_t<Base>, std::ranges::iterator_t<Base>>);
+  static_assert(CanMinus<decltype(sv_zero_offset_begin)>);
+  static_assert(std::forward_iterator<std::ranges::iterator_t<Base>>);
+
+  // Check positive __n with exact multiple of left's stride.
+  assert(sv_zero_offset_should_be_four - sv_zero_offset_should_be_one == 1);
+  assert(sv_zero_offset_should_be_seven - sv_zero_offset_should_be_one == 2);
+
+  // Check positive __n with non-exact multiple of left's stride.
+  assert(sv_one_offset_should_be_two - sv_zero_offset_should_be_one == 0);
+  assert(sv_one_offset_should_be_five - sv_zero_offset_should_be_one == 1);
+
+  // Check negative __n with exact multiple of left's stride.
+  assert(sv_zero_offset_should_be_one - sv_zero_offset_should_be_four == -1);
+  assert(sv_zero_offset_should_be_one - sv_zero_offset_should_be_seven == -2);
+
+  // Check negative __n with non-exact multiple of left's stride.
+  assert(sv_zero_offset_should_be_one - sv_one_offset_should_be_two == 0);
+  assert(sv_zero_offset_should_be_one - sv_one_offset_should_be_five == -1);
+
+  // Make sure that all sentinel operations work!
+  assert(stride_view_over_base_zero_offset.end() == std::default_sentinel);
+  assert(std::default_sentinel == stride_view_over_base_zero_offset.end());
+
+  assert(stride_view_over_base_zero_offset.end() - std::default_sentinel == 0);
+  assert(std::default_sentinel - stride_view_over_base_zero_offset.begin() ==
+         std::ranges::distance(stride_view_over_base_zero_offset));
+  assert(stride_view_over_base_zero_offset.begin() - std::default_sentinel ==
+         -std::ranges::distance(stride_view_over_base_zero_offset));
+  return true;
+}
+
+constexpr bool test_properly_handling_missing() {
+  // Check whether __missing_ gets handled properly.
+  using Base = BasicTestView<int*, int*>;
+  int arr[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+  auto base    = Base(arr, arr + 10);
+  auto strider = std::ranges::stride_view<Base>(base, 7);
+
+  auto strider_iter = strider.end();
+
+  strider_iter--;
+  assert(*strider_iter == 8);
+
+  // Now that we are back among the valid, we should
+  // have a normal stride length back (i.e., __missing_
+  // should be equal to 0).
+  strider_iter--;
+  assert(*strider_iter == 1);
+
+  strider_iter++;
+  assert(*strider_iter == 8);
+
+  // By striding past the end, we are going to generate
+  // another __missing_ != 0 value.
+  strider_iter++;
+  assert(strider_iter == strider.end());
+
+  // Make sure that all sentinel operations work!
+  assert(strider.end() == std::default_sentinel);
+  assert(std::default_sentinel == strider.end());
+
+  assert(strider_iter - std::default_sentinel == 0);
+  assert(std::default_sentinel - strider.end() == 0);
+  assert(std::default_sentinel - strider_iter == 0);
+
+  // Let's make sure that the newly regenerated __missing_ gets used.
+  strider_iter += -2;
+  assert(*strider_iter == 1);
+
+  return true;
+}
+
+int main(int, char**) {
+  {
+    constexpr int arr[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+    std::vector<int> vec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+    test_forward_operator_minus(arr, arr + 10);
+    test_forward_operator_minus(vec.begin(), vec.end());
+  }
+
+  {
+    int arr[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
+    test_non_forward_operator_minus(SizedInputIterator(arr), SizedInputIterator(arr + 1), SizedInputIterator(arr + 10));
+  }
+
+  test_properly_handling_missing();
+  static_assert(test_properly_handling_missing());
+  return 0;
+}
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/size.verify.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/size.verify.cpp
new file mode 100644
index 0000000000000..0accfc43258c4
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/size.verify.cpp
@@ -0,0 +1,56 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+// expected-no-diagnostics
+
+// constexpr auto size()
+
+#include <ranges>
+
+#include "__ranges/stride_view.h"
+#include "test_iterators.h"
+#include "types.h"
+
+// There is no size member function on a stride view over a view that
+// is *not* a sized range
+static_assert(!std::ranges::sized_range<BasicTestView<cpp17_input_iterator<int*>>>);
+static_assert(!std::ranges::sized_range<std::ranges::stride_view<BasicTestView<cpp17_input_iterator<int*>>>>);
+
+// There is a size member function on a stride view over a view that
+// *is* a sized range
+static_assert(std::ranges::sized_range<BasicTestView<int*, sentinel_wrapper<int*>, true>>);
+static_assert(std::ranges::sized_range<std::ranges::stride_view<BasicTestView<int*, sentinel_wrapper<int*>, true>>>);
+
+constexpr bool test() {
+  {
+    // Test with stride as exact multiple of number of elements in view strided over.
+    constexpr auto iota_twelve = std::views::iota(0, 12);
+    static_assert(std::ranges::sized_range<decltype(iota_twelve)>);
+    constexpr auto stride_iota_twelve = std::views::stride(iota_twelve, 3);
+    static_assert(std::ranges::sized_range<decltype(stride_iota_twelve)>);
+    static_assert(4 == stride_iota_twelve.size(), "Striding by 3 through a 12 member list has size 4.");
+  }
+
+  {
+    // Test with stride as inexact multiple of number of elements in view strided over.
+    constexpr auto iota_twenty_two = std::views::iota(0, 22);
+    static_assert(std::ranges::sized_range<decltype(iota_twenty_two)>);
+    constexpr auto stride_iota_twenty_two = std::views::stride(iota_twenty_two, 3);
+    static_assert(std::ranges::sized_range<decltype(stride_iota_twenty_two)>);
+    static_assert(8 == stride_iota_twenty_two.size(), "Striding by 3 through a 22 member list has size 8.");
+  }
+  return true;
+}
+
+int main(int, char**) {
+  test();
+  static_assert(test());
+
+  return 0;
+}
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/stride.pass.cpp b/libcxx/test/std/ranges/range.adaptors/range.stride.view/stride.pass.cpp
new file mode 100644
index 0000000000000..856e08c4649f7
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/stride.pass.cpp
@@ -0,0 +1,42 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
+
+// constexpr range_difference_t<_View> stride() const noexcept;
+
+#include <ranges>
+#include <type_traits>
+#include <utility>
+
+#include "test_iterators.h"
+#include "types.h"
+
+constexpr bool test() {
+  using View = BasicTestView<cpp17_input_iterator<int*>>;
+  int arr[]{1, 2, 3};
+  auto arrv(View(cpp17_input_iterator<int*>(arr), cpp17_input_iterator<int*>(arr + 3)));
+  // Mark str const so that we confirm that stride is a const member function.
+  const std::ranges::stride_view<View> str(arrv, 1);
+
+  // Make sure that stride member function is noexcept.
+  static_assert(noexcept(str.stride()));
+  // Make sure that the type returned by stride matches what is expected.
+  ASSERT_SAME_TYPE(std::ranges::range_difference_t<View>, decltype(str.stride()));
+  // Make sure that we get back a stride equal to the one that we gave in the ctor.
+  assert(str.stride() == 1);
+
+  return true;
+}
+
+int main(int, char**) {
+  test();
+  static_assert(test());
+
+  return 0;
+}
diff --git a/libcxx/test/std/ranges/range.adaptors/range.stride.view/types.h b/libcxx/test/std/ranges/range.adaptors/range.stride.view/types.h
new file mode 100644
index 0000000000000..de329bfa77aee
--- /dev/null
+++ b/libcxx/test/std/ranges/range.adaptors/range.stride.view/types.h
@@ -0,0 +1,259 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef TEST_STD_RANGES_RANGE_ADAPTORS_RANGE_STRIDE_TYPES_H
+#define TEST_STD_RANGES_RANGE_ADAPTORS_RANGE_STRIDE_TYPES_H
+
+#include <iterator>
+#include <ranges>
+#include <type_traits>
+
+#include "__iterator/concepts.h"
+#include "__ranges/common_view.h"
+#include "test_iterators.h"
+#include "test_range.h"
+
+// Concepts
+
+template <typename Iter>
+concept IterDifferable = requires(Iter& t) { t - t; };
+
+// Iterators
+
+template <class Derived, std::input_iterator Iter = int*, bool IsSized = false>
+  requires((!IsSized) || (IsSized && IterDifferable<Iter>))
+struct InputIterBase {
+  using iterator_concept  = std::input_iterator_tag;
+  using iterator_category = std::input_iterator_tag;
+  using value_type        = typename std::iterator_traits<Iter>::value_type;
+  using difference_type   = typename std::iterator_traits<Iter>::difference_type;
+
+  Iter value_{};
+
+  constexpr InputIterBase()                                      = default;
+  constexpr InputIterBase(const InputIterBase&)                  = default;
+  constexpr InputIterBase(InputIterBase&&)                       = default;
+  constexpr InputIterBase& operator=(const InputIterBase& other) = default;
+  constexpr InputIterBase& operator=(InputIterBase&& other)      = default;
+  constexpr explicit InputIterBase(Iter value) : value_(value) {}
+
+  constexpr value_type operator*() const { return *value_; }
+  constexpr Derived& operator++() {
+    value_++;
+    return static_cast<Derived&>(*this);
+  }
+  constexpr Derived operator++(int) {
+    auto nv = *this;
+    value_++;
+    return nv;
+  }
+  friend constexpr bool operator==(const Derived& left, const Derived& right) { return left.value_ == right.value_; }
+  friend constexpr difference_type operator-(const Derived& left, const Derived& right)
+    requires IsSized
+  {
+    return left.value_ - right.value_;
+  }
+};
+
+struct UnsizedInputIterator : InputIterBase<UnsizedInputIterator> {};
+static_assert(std::input_iterator<UnsizedInputIterator>);
+static_assert(!std::sized_sentinel_for<UnsizedInputIterator, UnsizedInputIterator>);
+
+struct SizedInputIterator : InputIterBase<SizedInputIterator, int*, true> {
+  using InputIterBase::InputIterBase;
+};
+static_assert(std::input_iterator<SizedInputIterator>);
+static_assert(std::sized_sentinel_for<SizedInputIterator, SizedInputIterator>);
+
+// Don't move/hold the iterator itself, copy/hold the base
+// of that iterator and reconstruct the iterator on demand.
+// May result in aliasing (if, e.g., Iterator is an iterator
+// over int *).
+template <class Iter, std::sentinel_for<Iter> Sent = sentinel_wrapper<Iter>>
+struct ViewOverNonCopyableIterator : std::ranges::view_base {
+  constexpr explicit ViewOverNonCopyableIterator(Iter it, Sent sent) : it_(base(it)), sent_(base(sent)) {}
+
+  ViewOverNonCopyableIterator(ViewOverNonCopyableIterator&&)            = default;
+  ViewOverNonCopyableIterator& operator=(ViewOverNonCopyableIterator&&) = default;
+
+  constexpr Iter begin() const { return Iter(it_); }
+  constexpr Sent end() const { return Sent(sent_); }
+
+private:
+  decltype(base(std::declval<Iter>())) it_;
+  decltype(base(std::declval<Sent>())) sent_;
+};
+
+// Put IterMoveIterSwapTestRangeIterator in a namespace to test ADL of CPOs iter_swap and iter_move
+// (see iter_swap.pass.cpp and iter_move.pass.cpp).
+namespace adl {
+template <std::input_iterator Iter = int*, bool IsIterSwappable = true, bool IsNoExceptIterMoveable = true>
+struct IterMoveIterSwapTestRangeIterator
+    : InputIterBase<IterMoveIterSwapTestRangeIterator<Iter, IsIterSwappable, IsNoExceptIterMoveable>, Iter, false> {
+  int* counter_{nullptr};
+
+  using InputIterBase<IterMoveIterSwapTestRangeIterator<Iter, IsIterSwappable, IsNoExceptIterMoveable>, Iter, false>::
+      InputIterBase;
+
+  constexpr IterMoveIterSwapTestRangeIterator(Iter value, int* counter)
+      : InputIterBase<IterMoveIterSwapTestRangeIterator<Iter, IsIterSwappable, IsNoExceptIterMoveable>, Iter, false>(
+            value),
+        counter_(counter) {}
+
+  friend constexpr void iter_swap(IterMoveIterSwapTestRangeIterator t, IterMoveIterSwapTestRangeIterator u) noexcept
+    requires IsIterSwappable && IsNoExceptIterMoveable
+  {
+    (*t.counter_)++;
+    (*u.counter_)++;
+    std::swap(*t.value_, *u.value_);
+  }
+
+  friend constexpr void iter_swap(IterMoveIterSwapTestRangeIterator t, IterMoveIterSwapTestRangeIterator u)
+    requires IsIterSwappable && (!IsNoExceptIterMoveable)
+  {
+    (*t.counter_)++;
+    (*u.counter_)++;
+    std::swap(*t.value_, *u.value_);
+  }
+
+  friend constexpr auto iter_move(const IterMoveIterSwapTestRangeIterator& t)
+    requires(!IsNoExceptIterMoveable)
+  {
+    (*t.counter_)++;
+    return *t.value_;
+  }
+  friend constexpr auto iter_move(const IterMoveIterSwapTestRangeIterator& t) noexcept
+    requires IsNoExceptIterMoveable
+  {
+    (*t.counter_)++;
+    return *t.value_;
+  }
+};
+} // namespace adl
+
+template <typename Iter = int*, bool IsSwappable = true, bool IsNoExcept = true>
+struct IterMoveIterSwapTestRange : std::ranges::view_base {
+  adl::IterMoveIterSwapTestRangeIterator<Iter, IsSwappable, IsNoExcept> begin_;
+  adl::IterMoveIterSwapTestRangeIterator<Iter, IsSwappable, IsNoExcept> end_;
+  constexpr IterMoveIterSwapTestRange(const Iter& begin, const Iter& end, int* counter)
+      : begin_(adl::IterMoveIterSwapTestRangeIterator<Iter, IsSwappable, IsNoExcept>(begin, counter)),
+        end_(adl::IterMoveIterSwapTestRangeIterator<Iter, IsSwappable, IsNoExcept>(end, counter)) {}
+  constexpr adl::IterMoveIterSwapTestRangeIterator<Iter, IsSwappable, IsNoExcept> begin() const { return begin_; }
+  constexpr adl::IterMoveIterSwapTestRangeIterator<Iter, IsSwappable, IsNoExcept> end() const { return end_; }
+};
+
+// Views
+
+template <bool View>
+struct ViewOrRange {};
+
+template <>
+struct ViewOrRange<true> : std::ranges::view_base {};
+
+template <std::input_iterator Iter,
+          std::sentinel_for<Iter> Sent = sentinel_wrapper<Iter>,
+          bool IsSized                 = false,
+          bool IsView                  = false>
+  requires((!IsSized) || (IsSized && IterDifferable<Iter>))
+struct BasicTestViewOrRange : ViewOrRange<IsView> {
+  Iter begin_{};
+  Iter end_{};
+
+  constexpr BasicTestViewOrRange(Iter b, Iter e) : begin_(b), end_(e) {}
+
+  constexpr Iter begin() { return begin_; }
+  constexpr Iter begin() const { return begin_; }
+  constexpr Sent end() { return Sent{end_}; }
+  constexpr Sent end() const { return Sent{end_}; }
+
+  constexpr auto size() const
+    requires IsSized
+  {
+    return begin_ - end_;
+  }
+};
+
+template <std::input_iterator Iter, std::sentinel_for<Iter> Sent = sentinel_wrapper<Iter>, bool IsSized = false>
+  requires((!IsSized) || (IsSized && IterDifferable<Iter>))
+using BasicTestView = BasicTestViewOrRange<Iter, Sent, IsSized, true>;
+
+template <std::input_iterator Iter, std::sentinel_for<Iter> Sent = sentinel_wrapper<Iter>, bool IsCopyable = true>
+struct MaybeCopyableAlwaysMoveableView : std::ranges::view_base {
+  Iter begin_;
+  Iter end_;
+
+  constexpr explicit MaybeCopyableAlwaysMoveableView(Iter b, Iter e) : begin_(b), end_(e) {}
+
+  constexpr MaybeCopyableAlwaysMoveableView(MaybeCopyableAlwaysMoveableView&& other)      = default;
+  constexpr MaybeCopyableAlwaysMoveableView& operator=(MaybeCopyableAlwaysMoveableView&&) = default;
+
+  constexpr MaybeCopyableAlwaysMoveableView(const MaybeCopyableAlwaysMoveableView&)
+    requires(!IsCopyable)
+  = delete;
+  constexpr MaybeCopyableAlwaysMoveableView(const MaybeCopyableAlwaysMoveableView&)
+    requires IsCopyable
+  = default;
+
+  constexpr MaybeCopyableAlwaysMoveableView& operator=(const MaybeCopyableAlwaysMoveableView&)
+    requires(!IsCopyable)
+  = delete;
+  constexpr MaybeCopyableAlwaysMoveableView& operator=(const MaybeCopyableAlwaysMoveableView&)
+    requires IsCopyable
+  = default;
+
+  constexpr Iter begin() const { return begin_; }
+  constexpr Sent end() const { return Sent{end_}; }
+};
+static_assert(std::ranges::view<MaybeCopyableAlwaysMoveableView<cpp17_input_iterator<int*>>>);
+static_assert(std::ranges::view<MaybeCopyableAlwaysMoveableView<cpp17_input_iterator<int*>,
+                                                                sentinel_wrapper<cpp17_input_iterator<int*>>,
+                                                                false>>);
+
+static_assert(std::copyable<MaybeCopyableAlwaysMoveableView<cpp17_input_iterator<int*>>>);
+template <std::input_iterator Iter, std::sentinel_for<Iter> Sent = sentinel_wrapper<Iter>>
+using CopyableView = MaybeCopyableAlwaysMoveableView<Iter, Sent>;
+static_assert(std::copyable<CopyableView<cpp17_input_iterator<int*>>>);
+
+template <std::input_iterator Iter, std::sentinel_for<Iter> Sent = sentinel_wrapper<Iter>>
+using MoveOnlyView = MaybeCopyableAlwaysMoveableView<Iter, Sent, false>;
+static_assert(!std::copyable<MoveOnlyView<cpp17_input_iterator<int*>>>);
+
+template <bool IsSimple, bool IsConst = IsSimple, bool IsCommon = true>
+struct MaybeConstCommonSimpleView : std::ranges::view_base {
+  int* begin();
+  int* begin() const
+    requires(IsConst && IsSimple);
+  double* begin() const
+    requires(IsConst && !IsSimple);
+
+  int* end()
+    requires(IsCommon);
+  void* end()
+    requires(!IsCommon);
+
+  int* end() const
+    requires(IsConst && IsCommon && IsSimple);
+  double* end() const
+    requires(IsConst && IsCommon && !IsSimple);
+
+  void* end() const
+    requires(IsConst && !IsCommon);
+};
+
+using UnSimpleNoConstCommonView = MaybeConstCommonSimpleView<false, false, true>;
+using UnsimpleConstView         = MaybeConstCommonSimpleView<false, true, true>;
+using UnsimpleUnCommonConstView = MaybeConstCommonSimpleView<false, true, false>;
+using SimpleUnCommonConstView   = MaybeConstCommonSimpleView<true, true, false>;
+
+// Ranges
+
+template <std::input_iterator Iter, std::sentinel_for<Iter> Sent = sentinel_wrapper<Iter>, bool IsSized = false>
+  requires((!IsSized) || (IsSized && IterDifferable<Iter>))
+using BasicTestRange = BasicTestViewOrRange<Iter, Sent, IsSized, false>;
+
+#endif // TEST_STD_RANGES_RANGE_ADAPTORS_RANGE_STRIDE_TYPES_H
diff --git a/libcxx/utils/generate_feature_test_macro_components.py b/libcxx/utils/generate_feature_test_macro_components.py
index b04cb4f511554..46d1c4dd98c42 100755
--- a/libcxx/utils/generate_feature_test_macro_components.py
+++ b/libcxx/utils/generate_feature_test_macro_components.py
@@ -1015,6 +1015,11 @@ def add_version_header(tc):
             "values": {"c++23": 202106},
             "headers": ["algorithm"],
         },
+        {
+            "name": "__cpp_lib_ranges_stride",
+            "values": {"c++23": 202207},
+            "headers": ["ranges"],
+        },
         {
             "name": "__cpp_lib_ranges_to_container",
             "values": {"c++23": 202202},
